> Operationg System Concepts 책을 읽고 정리한 내용입니다.

# 1장

## 운영체제란 무엇인가?

### 정의 및 역할
- 정의: 컴퓨터 하드웨어와 컴퓨터 사용자 사이의 중재자 역할을 하는 프로그램.
- 핵심목표
  - 사용자 프로그램을 실행하고 문제를 쉽게 해결할 수 있게 한다.
  - 컴퓨터 시스템을 편리하게 사용할 수 있게 한다.
  -  컴퓨터 하드웨어를 효율적으로 사용할 수 있게 한다.

### 운영체제의 범위
- 커널: 컴퓨터에서 항상 실행되는 단 하나의 프로그램(OS의 핵심)
- 시스템 프로그램: 커널과함께 제공되지만 커널의 일부는 아닌것들.
- 미들웨어:응용 개발자에게 추가적인 서비스를 제공하는 소프트웨어 프레임워크 (모바일 OS 등에서 중요).

## 컴퓨터 시스템의 구성

### 인터럽트
- 개념: 하드웨어나 소프트웨어가 CPU에 이벤트를 알리는 메커니즘.
- 작동 원리
  - CPU가 작업을 수행하는 중에 인터럽트 발생
  - CPU는 현재 작업을 중지하고 즉시 인터럽트 서비스 루틴(ISR)의 실행 위치로 이동.
  - 서비스 루틴 완료 후, 중단되었던 작업 재개.
- 유형
  - 하드웨어 인터럽트: 시스템 버스를 통해 신호 전달(키보드 입력, 디스크 완료 등)
  - 소프트웨어 인터럽트(Trap/Exception): 오류나 사용자 요청에 의해 발생.

### 저장 장치 구조
- 폰노이만 구조: 모든 명령어와 데이터는 실행전 메인 메모리(RAM)에 있어야한다.
- 저장장치 계층 구조: 상위로 갈 수록 빠름,비쌈,용량 작음,휘발성
   - 레지스터 (Registers)
   - 캐시 (Cache)
   - 메인 메모리 (Main Memory - RAM): 휘발성. CPU가 직접 접근 가능.
   - 비휘발성 메모리 (NVM/SSD): 메인 메모리보다 느리지만 영구 저장.  - 하드 디스크 드라이브 (HDD)
   - 광학 디스크, 자기 테이프

### 입출력 구조
- 장치 컨트롤러: 각 장치 유형을 담당하는 하드웨어 칩. 로컬 버퍼를 가진다.
- 장치 드라이버: OS 내에서 장치 컨트롤러와 통신하는 소프트웨어.
- DMA
  - 대량의 데이터를 이동할 때 CPU의 개입없이 장치 컨트롤러가 직접 메모리에 데이터를 전송하는 방식.
  - 데이터 블록 전송이 끝났을 때만 CPU에 인터럽트를 건다(CPU 부하 감소).

## 컴퓨터 시스템 아키텍처

### 단일 프로세서 시스템
- 하나의 메인 CPU만 존재.

### 멀티 프로세서 시스템
- 장점: 처리량 증가, 규모의 경제(비용 절감), 신뢰성 향상.
- 종류
  - 대칭형 멀티프로세싱(SMP): 모든 프로세서가 대등하며 메모리를 공유함.(가장 일반적)
  - 멀티코어: 하나의 칩안에 여러개의 계산 코어를 내장. 에너지 효율적이고 빠르다.

### 클러스터 시스템
- 여러개의 독립적인 시스템을 네트워크로 연결.
- 높은 가용성 제공이 주목적이다. 하나가 고장나도 서비스 지속이 가능.

## 운영체제의 작동

### 부트스트랩 프로그램
- 전원 켜질 때 실행. 하드웨어를 초기화하고 OS 커널을 메모리 로드하여 실행한다.

### 멀티프로그래밍 vs 멀티태스킹
- 멀티프로그래밍
  - CPU가 쉴 틈을 주지않는다.(효율성 극대화)
  - 여러 작업을 메모리에 올려두고, 하나가 I/O 대기 상태가되면 즉시 다른 작업으로 전환한다.
- 멀티태스킹
  - CPU가 작업을 아주 짧은 시간 간격으로 교체하며 실행.
  - 사용자가 각 프로그램과 상호작용을 할 수 있게 한다.(응답 시간이 중요)

### 이중 모드 운용
- 사용자 프로그램이 시스템에 해를 끼치는 것을 방지하기 위한 하드웨어 지원.
- 모드 비트 (Mode Bit): 0(커널 모드) / 1(사용자 모드).
- 특권 명령 (Privileged Instruction): 커널 모드에서만 실행 가능한 위험한 명령(I/O 제어, 타이머 변경 등).
- 사용자가 특권 명령을 수행하려면 시스템 호출(System Call)을 통해 OS에 요청해야 함.

### 타이머
특정 프로그램이 CPU를 무한정 점유하는 것을 막기 위해 일정 시간 후 인터럽트를 발생시켜 OS에게 제어권을 넘김.

## 자원 관리
OS는 시스템의 자원 관리자(Resource Manager)이다.

1. 프로세스 관리 (Process Management):
   - 프로세스: 실행 중인 프로그램.
   - 역할: 프로세스 생성/삭제, 일시정지/재개, 동기화, 통신, 교착상태 처리.
2. 메모리 관리 (Memory Management):
   - CPU가 처리하려면 데이터가 메모리에 있어야 함.
   - 역할: 메모리의 어느 부분이 사용 중인지 추적, 할당 및 회수.
3. 파일 시스템 관리 (File-System Management):
   - 물리적 저장소를 논리적 단위(파일)로 추상화.
   - 역할: 파일/디렉터리 생성 및 삭제, 접근 제어, 백업.
4. 대용량 저장소 관리 (Mass-Storage Management):
   - 디스크 스케줄링 (헤드 움직임 최적화), 여유 공간 관리.
5. 캐싱 (Caching):
   - 빠른 저장소에 데이터를 임시 복사하여 성능 향상.
   - 캐시 일관성 (Coherency): 멀티태스킹/멀티프로세서 환경에서 여러 캐시의 데이터가 최신 값으로 일치하도록 관리하는 것이 중요.
6. I/O 시스템 관리:
   - 버퍼링, 캐싱, 스풀링, 장치 드라이버 인터페이스 제공.


## 보안과 보호
- 보호 (Protection): 컴퓨터 시스템 자원에 대한 프로세스나 사용자의 접근을 제어하는 내부 메커니즘. (권한 관리)
- 보안 (Security): 바이러스, 웜, 해킹 등 외부의 공격으로부터 시스템을 방어하는 것.



## 가상화와 분산 시스템

### 가상화 (Virtualization)
- 한 컴퓨터의 하드웨어를 여러 실행 환경으로 추상화하는 기술.
- VMM (Virtual Machine Manager): 호스트 OS 위에서 게스트 OS를 실행하게 해줌 (예: VMware, VirtualBox).

### 분산 시스템 (Distributed Systems)
- 물리적으로 떨어져 있는 컴퓨터들이 네트워크로 연결되어 작업을 처리.
- TCP/IP가 가장 일반적인 프로토콜.


## 오늘의 회고
- 운영체제는 단순한 프로그램 실행기가 아니라, 하드웨어의 복잡성을 숨기고(추상화) 자원을 효율적으로 배분하는 거대한 관리자이다.
- 현대의 OS는 멀티코어, 모바일, 클라우드 가상화 환경까지 커버해야 하므로 그 역할이 방대해졌다.

# 3장

## 프로세스 개념

### 정의
- 프로세스: 실행중인 프로그램
- 프로그램 vs 프로세스
  - 프로그램: 디스크에 저장된 파일(실행 파일). 수동적인 존재.
  - 프로세스: 메모리에 적재되어 CPU에 실행되는 상태. 능동적인 존재.

### 메모리 내 프로세스 구조
프로세스는 메모리상에서 다음과 같은 섹션으로 구성된다.
1. 텍스트(Text)섹션: 실행 코드가 저장.
2. 데이터(Data)섹션: 전역 변수, 정적 변수
3. 힙(Heap)섹션: 런타임 중에 동적으로 할당되는 메모리.
4. 스택(Stack)섹션: 함수 호출 시 임시 데이터 저장(함수 매개변수, 복귀 주소, 로컬 변수)

## 프로세스 상태
프로세스는 실행되면서 상태가 변한다.
1. New(생성): 프로세스가 막 생성된 상태.
2. Running(실행): 명령어들이 실행되고있는 상태(CPU 점유).
3. Waiting(대기): 특정 이벤트(I/O완료, 신호 수신)를 기다리는 상태.
4. Ready(준비): CPU를 할당받기를 기다리는 상태(메모리에 올라옴)
5. Terminated(종료): 실행을 마치고 제거된 상태.

## 프로세스 제어블록(PCB)
OS가 각 프로세스를 관리하기 위해 유지하는 정보저장소. TCB라고도 한다.

### PCB에 저장된 정보
- 프로세스 상태 (Process State): new, ready, running 등.
- 프로그램 카운터 (Program Counter): 다음에 실행할 명령어의 주소.
- CPU 레지스터: 누산기, 인덱스 레지스터, 스택 포인터 등 문맥 정보.
- CPU 스케줄링 정보: 우선순위, 스케줄링 큐 포인터.
- 메모리 관리 정보: 베이스/리미트 레지스터 값, 페이지 테이블 등.
- 회계(Accounting) 정보: CPU 사용 시간, 프로세스 번호(PID).
- I/O 상태 정보: 할당된 I/O 장치 목록, 열린 파일 목록.

## 프로세스 스케줄링
CPU 활용률을 최대화하고, 프로세스 간 신속한 전환을 위해 스케줄러가 필요.

### 스케줄링 큐
- 준비 큐: 메모리에 있으면서 CPU 할당을 기다리는 프로세스들 집합(주로 연결 리스트).
- 대기 큐: 특정 I/O 장치나 이벤트를 기다리는 프로세스들 집합.

### 문맥 교환
- 개념: CPU를 다른 프로세스로 넘겨주기 위해, 현재 프로세스의 상태(PCB)를 저장하고, 새 프로세스의 상태를 복원하는 작업.
- 특징
  - 문맥교환이 이루어지는 동안 시스템은 유용한 작업이 불가능하다. 따라서 오버헤드가 발생한다.
  - 하드웨어 지원 정도에 따라 속도 차이가 발생한다.

## 프로세스에 대한 연산

### 프로세스 생성
- 트리 구조: 부모 프로세스가 자식 프로세스를 생성하며 트리를 형성한다.
- PID: 각 프로세스를 식별하는 고유 번호(Linux에서는 `systemd`가 모든 프로세스의 조상.)
- UNIX/Linux 시스템 호출
  - `fork()`: 새로운 프로세스를 생성. 부모의 주소 공간을 그대로 복사한다.(부모는 pid > 0, 자식은 pid = 0 반환.)
  - `exec()`: `fork()`후 메모리 공간을 새로운 프로그램으로 덮어쓴다.
  - `wait()`: 자식 프로세스가 종료될 때까지 부모가 기다린다.

### 프로세스 종료
- 정상 종료: 마지막 문장 실행후 `exit()`시스템 호출.
- 좀비 프로세스: 자식이 종료되었으나, 부모가 아직 `wait()`을 호출하지 않아 프로세스 테이블에 정보가 남아있는 상태.
- 고아 프로세스: 부모가 자식보다 먼저 종료되어 버린 상태.

## 프로세스간 통신 (IPC)
프로세스는 독립적일수도 있지만, 협력적일수도 있다. 협력 프로세스간에는 데이터 공유가 필요하다.

### IPC의 두 가지 기본 모델
- 공유 메모리 (Shared Memory)
  - 방식: 특정 메모리 영역을 두 프로세스가 함께 읽고 씀.
  - 장점: 커널을 거치지 않으므로 속도가 매우 빠름.
  - 단점: 동기화(Synchronization) 문제를 응용 프로그램 수준에서 해결해야 함. (예: 생산자-소비자 문제).
- 메시지 전달 (Message Passing)
  - 방식: OS 커널을 통해 메시지를 주고받음 (`send(), receive()`).
  - 장점: 충돌 회피가 쉽고, 분산 시스템(네트워크)에서 구현이 용이.
  - 단점: 시스템 콜(System Call)을 사용하므로 공유 메모리보다 느림.

### 통신 동기화 (Synchronization)
- Blocking(동기식): 메시지가 수신될 때까지 송신자/수신자가 대기.
- Non-blocking(비동기식): 작업을 요청하고 즉시 다른 작업을 수행.

## 클라이언트-서버 환경에서의 통신
### 소켓
- 통신의 끝점(Endpoint)
- 구성: `IP주소` + `포트 번호`
- 저수준 통신 방식으로, 바이트 스트림만 주고받는다.(데이터 구조화는 응용 프로그램의 책임)

### 파이프
- 두 프로세스간의 통신 통로.
- 익명 파이프: 부모-자식 관계에서만 사용이 가능하다. 단방향 통신. 프로세스 종료시 사라진다.
- 지명 파이프: 부모-자식 관계가 아니더라도 통신이 가능하다. 양방향 가능. 프로세스가 종료되어도 유지된다.

## 오늘의 회고
- 프로그램은 코드 덩어리이고, 프로세스는 살아 움직이는 실행 주체이다.
- OS는 PCB라는 명찰을 통해 수많은 프로세스를 관리하며, CPU를 아주 짧게 번갈아 쓰게 함으로써(Context Switch) 사용자가 동시에 여러 작업이 된다고 느끼게 한다.
- 프로세스 생성의 핵심은 `fork()(복제)와 exec()(덮어쓰기)`의 협력이다.
- 프로세스끼리 대화(IPC)하려면 '메모리를 같이 쓰거나(Shared Memory)', '우체부(OS)를 통해 편지를 주고받아야(Message Passing)' 한다.

