> HTTP 완벽 가이드 책을 읽고 정리한 내용입니다.

# HTTP 개관

## HTTP: 인터넷의 멀티미디어 배달부
HTTP는 단순한 텍스트 전송규약이 아닌, 전 세계 웹 서버와 클라이언트 간의 신뢰성있는 데이터 전송을 보장하는 애플리케이션 계층 프로토콜이다.

### 리소스와 MIME 타입
- 리소스: 웹에 존재하는 모든 컨텐츠(파일, 게이트웨이 프로그램, 검색 결과 등)을 총칭
- MIME 타입:
  - 원래 이메일 전송을 위해 설계되었으나 HTTP에서도 사용된다.
  - 서버는 데이터 전송시 `Content-Type` 헤더를 통해 데이터의 형식을 알려준다.

### URI (Uniform Resource Identifier)
리소스의 고유 식별자. URI는 URL과 URN으로 나뉜다.
- URL(Locator): 리소스의 위치를 지정. 가장 일반적인 형태.
  - 구조: `<스킴>://<서버주소>:<포트>/<경로>`
  - 예: `http://www.naver.com:80/index.html`
- URN(Name): 리소스의 이름을 지정. 위치가 변해도 이름은 유지.
  - 예: `urn:isbn:978-0-123-45678-9`(아직 널리 쓰이지는 않는다.)

---

## HTTP 트랜잭션
HTTP 트랜잭션은 요청(Request)와 응답(Response) 결과로 구성된다.

### 메서드: 서버에게 무엇을 시키는가
모든 서버가 모든 메서드를 지원하는것은 아님.
- GET: 리소스를 서버에서 클라이언트로 가져온다. (가장 많이 사용)
- POST: 클라이언트가 서버로 데이터를 보낸다. (입력 폼 전송 등)
- PUT: 서버에 문서를 저장하거나 덮어쓴다.
- DELETE: 서버에서 리소스를 삭제한다.
- HEAD: GET과 같지만, 본문(Body) 없이 헤더만 가져온다. (리소스 존재 여부 확인, 변경 여부 검사 시 유용)

### 상태코드: 결과가 어떠한가
세 자리 숫자로 구성되며, 함께 오는 사유 구문은 사람이 이해하기 위한 것.
- 100-199: 정보 (Information)
- 200-299: 성공 (Success) -> 200 OK
- 300-399: 리다이렉션 (Redirection) -> 302 Found (다른 위치로 가라)
- 400-499: 클라이언트 에러 (Client Error) -> 404 Not Found (네가 요청한 게 없다)
- 500-599: 서버 에러 (Server Error) -> 500 Internal Server Error (서버 내부 문제)

---

## 메시지 구조
HTTP 메시지는 인간이 읽을 수 있는 텍스트로 되어있다.

### 요청 메시지 (Request)
1. 시작줄: `<메서드> <URL> <버전>`
   - 예: `GET /index.html HTTP/1.1`
2. 헤더: 키: 값 형태의 메타 정보.(빈 줄로 헤더의 끝을 알린다.)
3. 본문: POST 요청시 보낼 데이터

### 응답 메시지 (Response)
1. 시작줄: `<버전> <상태코드> <사유구문>`
   - 예: `HTTP/1.1 200 OK`
2. 헤더: 컨텐츠 타입, 길이, 서버 정보 등.
3. 본문: 실제 데이터

---

## TCP 커넥션
HTTP는 네트워크 통신의 핵심인 데이터 전송을 TCP/IP에 맡긴다.

### 계층 구조
1. HTTP (애플리케이션 계층): 무엇을 보낼지 결정.
2. TCP (전송 계층): 데이터를 패킷 단위로 쪼개고, 순서대로, 에러 없이 도착하도록 보장.
3. IP (네트워크 계층): 목적지 컴퓨터(IP 주소)까지 패킷을 배달.
4. 네트워크 인터페이스: 실제 물리적인 선.

### 접속 과정 (브라우저가 URL을 쳤을 때)
1. 브라우저가 URL에서 호스트명(www.google.com)을 추출한다.
2. 브라우저가 DNS 서버에 호스트명의 IP 주소를 물어본다
3. IP 주소를 얻으면, 포트 번호(HTTP는 기본 80)를 확인한다.
4. 브라우저가 해당 IP:Port로 TCP 커넥션을 맺는다.
5. 브라우저가 HTTP 요청 메시지를 보낸다.
6. 서버가 HTTP 응답 메시지를 보낸다.
7. 커넥션을 끊는다 (HTTP/1.1의 Keep-Alive 설정에 따라 유지될 수도 있음).

---

## 웹의 구성 요소
인터넷은 단순한 1:1 연결이 아니라 중간에 수많은 중개자가 존재한다.
1. 프락시(Proxy): 클라이언트와 서버 사이에서 HTTP 메시지를 정리하거나, 보안 검사를 수행하는 중개 서버.
2. 캐시(Cache): 자주 요청받는 리소스의 사본을 저장해두는 특별한 종류의 프락시. 서버 부하를 줄이고 응답 속도를 높인다.
3. 게이트웨이(Gateway): 다른 프로토콜을 HTTP로 변환해준다.
   - 예: HTTP 트래픽을 받아서 SQL 쿼리로 변환해 DB에 접속하는 서버.
4. 터널(Tunnel): HTTP 메시지를 엿보지 않고 그대로 전달만 해주는 파이프.
   - 예: SSL/TLS(HTTPS) 통신 시 암호화된 데이터를 통과시킬 때 사용.
5. 에이전트(Agent): HTTP 요청을 발생시키는 주체.
    - 대표적인 예: 웹 브라우저, 웹 크롤러(스파이더).

---

## 오늘의 회고
1. 단순함의 미학: HTTP 메시지는 바이너리(0과 1)가 아니라 텍스트로 되어 있다. 이는 디버깅을 쉽게 하고 프로토콜의 확장을 용이하게 했다는 점이 인상 깊다. (Telnet으로 직접 요청을 날려볼 수 있는 이유)
2. 상태 코드의 분류: 단순히 에러가 났다가 아니라, 4xx는 내(클라이언트) 잘못, 5xx는 서버 잘못이라는 책임 소재를 명확히 숫자로 구분한 설계가 효율적이다.
3. 계층의 분리: HTTP는 '어떻게 보낼지(Routing)'를 고민하지 않는다. 그건 TCP/IP가 한다. HTTP는 오직 '무엇을 보낼지'에만 집중한다. 이 추상화가 웹의 폭발적 성장을 가능하게 했다.

---
# URL과 리소스

## URL: 인터넷의 탐색 도구
URL은 브라우저가 리소스를 찾고, 사용하고, 가져오기 위해 필요한 모든 정보를 담고 있는 표준화된 이름이다.
- 역할: 리소스가 어디에 있고, 어떻게 접근해야하는지 알려준다.
- 구성: `스킴(Scheme)` + `호스트(Host)` + `경로(Path)`

---

## URL 문법
URL은 생각보다 복잡한 구조를 가질 수 있다. 일반적인 포맷은 다음과 같다.
`py <스킴>://<사용자이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>`

### 각 구성요소의 역할
- 스킴(Scheme): 사용할 프로토콜을 정의.(대소문자 구별x, 보통 소문자 사용)
   - 예: `http, htpps, mailto, ftp` 등
   - 구분자: 뒤에 `://`가 붙는다.
- 사용자 이름 & 비밀번호: 데이터 접근시 인증이 필요한 경우 사용.
  - 예: `ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu`
  - 당연하게도 비밀번호를 URL에 평문으로 넣는것은 보안에 취약하기 때문에 거의 사용x
- 호스트 & 포트: 리소스를 가진 서버의 위치.
  - 호스트: 도메인명`www.google.com`또는 IP 주소.
  - 포트: 서버가 열고 있는 문. 80, 443 등
- 경로(Path): 서버내 리소스의 계층적 위치 `/`문자로 구분한다.
- 파라미터(Parameters): 애플리케이션에 필요한 추가 정보 전달. `;`문자로 구분한다.
  - 예: `/hammers;sale=false/index.html;graphics=true`
  - 참고: 경로의 각 세그먼트마다 파라미터가 붙을 수 있다.
- 질의 문자열(쿼리문): 데이터베이스나 게이트웨이에 파라미터 전달.
  - 예: `?item=12731&color=blue`
  - 구분자 `?`로 시작하며, `&`로 키-값 쌍을 나눈다.
- 프래그먼트(Fragment): 리소스 내부의 특정 조각(섹션)을 가리킨다.
  - 예: `#section-2`
  - 핵심: 프래그먼트는 서버로 전송되지 않는다. 브라우저(클라이언트)가 전체 문서를 받은 뒤 해당 위치로 이동하는 용도로만 사용.

---

## URL 단축과 상대 URL
항상 전체 URL(절대)을 다 쓰는 것은 비효율적이다. HTML 내에서는 상대 URL을 많이 사용한다.

### 기저(Base) URL
상대 URL을 해석하려면 기준이 되는 기저 URL이 필요하다.
1. 리소스 자체의 URL: 현재 보고 있는 페이지의 URL이 기저.
2. 명시적 설정: HTML의 `<base href="...">` 태그로 기저 URL을 고정할 수 있다.

### 상대 경로 해석법
유닉스/리눅스의 파일 시스템 경로와 유사.
- `./`:현재 디렉터리
- `../`: 상위 디렉터리
- `/`로 시작: 도메인 루트(Root)에서 시작
- 예) 기저가 `http://www.a.com/b/c/d.html` 일 때,
  - `e.html` -> `http://www.a.com/b/c/e.html`
  - `/f.html` -> `http://www.a.com/f.html`
---

## URL 인코딩
컴퓨터는 이진 데이터를 다루지만, URL은 안전한 정송을 위해 ASCII 문자 집합만을 사용해야함. 따라서 안전하지 않는 문자는 인코딩해서 사용해야 한다.

### 안전하지 않은 문자
- 출력 불가능한 문자: 제어 문자 등.
- 예약된 문자: URL에서 특별한 의미로 이미 사용중인 문자들 `(/, :, ?, @, & 등)`. 이들을 문자 그대로 데이터로 쓰고 싶다면 인코딩해야 한다.
- 비 ASCII 문자: 한글, 일본어 등 영어 이외의 문자.

### 이스케이프 문자열
안전하지 않은 문자를 `%` + `16진수 두 자리(Hex)`로 바꾼다.
- **스페이스(공백):** ASCII 32 -> %20
- **~ (물결표):** ASCII 126 -> %7E
- **한글:** UTF-8 바이트 값을 각각 %로 변환.

---

## 여러가지 스킴
- http: 일반적인 웹 통신.
- https: SSL/TLS로 암호화된 안전한 http.
- mailto: 이메일 보내기. (예: `mailto:jo@jo.com`)
- ftp: 파일 전송 프로토콜.
- rtsp: 실시간 스트리밍 프로토콜.
- file: 로컬 컴퓨터의 파일에 접근.

---

## 오늘의 회고
1. 프래그먼트(#)의 비밀: # 뒤의 내용은 서버 요청 로그에 남지 않는다는 점이 중요하다. 요즘 SPA(Single Page Application)에서 라우팅을 할 때 HashRouter를 쓰면 서버 설정 없이도 페이지 이동처럼 보이는 이유가 바로 이것이다.
2. 인코딩의 중요성: 개발하다 보면 검색어 파라미터에 특수문자(& 등)가 들어가서 쿼리 스트링이 깨지는 경우가 있다. 이때 반드시 encodeURIComponent 같은 함수로 인코딩을 해줘야 함을 이론적으로 재확인했다.
3. URL의 미래와 한계: URL은 리소스가 옮겨지면 링크가 깨지는(Link Rot) 문제가 있다. 이를 해결하기 위해 URN(이름)이 나왔지만, 인프라 비용과 표준화 문제로 여전히 URL이 지배적이라는 현실.

---

# HTTP 메시지

## 메시지의 흐름
HTTP 메시지는 강물 처럼 흐름이 존재한다.

- 인바운드 vs 아웃바운드
  - 트랜잭션 방향을 기준으로 한다.
  - 메시지가 원 서버로 향하면 인바운드.
  - 메시지가 사용자 에이전트로 돌아오면 아웃바운드.
- 다운 스트림
  - 모든 메시지(요청이든 응답이든)는 다운스트림으로 흐른다.
  - 발송자 -> 수신자 방향이 물이 흐르는 방향이다.(거꾸로 거슬러 올라가는 메시지는 존재하지않는다.)

---

## 메시지의 해부
HTTP 메시지는 세 부분으로 나뉜다. 엄격한 규칙은 **CRLF(캐리지 리턴 + 개행)**으로 구분된다는 점이다.

`py <시작줄> (CRLF) <헤더> (CRLF) <빈 줄> (CRLF) --> 헤더의 끝을 알리는 매우 중요한 경계선 <본문>`

### 구성 요소
- 시작줄: 이것이 어떤 메시지인지 정의.
  - 요청: `<메서드> <URL> <버전> (예: GET /home HTTP/1.1)`
  - 응답: `<버전> <상태코드> <사유구문> (예: HTTP/1.1 200 OK)`
- 헤더: 속성 정보. `(예: Content-Type: text/html)`
- 본문: 페이로드. 이미지, 비디오, HTML 문서, 텍스트 등. 본문이 없을수도 있다.

---

## 메서드 심화
단순히 동작을 지시하는 것을 넘어, 안전성과 멱등성이란 속성을 이해하는것이 핵심.

### 주요 메서드
- GET: 리소스 요청.
- HEAD: 리소스의 헤더만 요청. (본문은 안 옴).
  - 용도: 리소스가 살아있는지, 변경되었는지(Last-Modified), 타입이 무엇인지 미리 확인할 때 효율적.
- POST: 서버에 입력 데이터 전송. (보통 처리 주체는 서버의 게이트웨이 프로그램).
- PUT: 리소스를 생성하거나, 있으면 덮어씌움(Update).
- DELETE: 리소스 삭제.
- TRACE: 루프백(Loopback) 테스트.
  - 클라이언트가 보낸 요청이 프락시들을 거치며 어떻게 변조되는지 서버가 그대로 반송해서 보여줌. (디버깅용)
- OPTIONS: 서버가 특정 리소스에 대해 어떤 메서드를 지원하는지 물어봄.

### 안전성과 멱등성
1. 안전한 메서드: `GET, HEAD`
   - 서버의 상태를 바꾸지 않는다(Read Only).
   - 크롤러가 막 호출해도 서버에 영향을 주지 않아야한다.
2. 멱등성:
   - 연산을 한 번 하든, 백 번 하든 결과가 똑같은 성질.
   - 멱등함: `GET, PUT, DELETE`
     - `PUT`: 같은 내용으로 100번 덮어써도, 결과물은 그 내용 하나이다.
     - `DELETE`: 한 번 삭제하나, 삭제된걸 또 삭제 요청하나 삭제된 상태는 같다.
  - 멱등하지 않음: `POST`
    - 게시글 작성 버튼을 100번 누르면 게시글이 100개 생긴다. (따라서 결제 페이지 등에서 중복 전송 방지가 중요.)
---

## 상태 코드 상세
상태 코드는 클라이언트 소프트웨어(브라우저)가 처리하는 기준이고, 사유 구문(Reason Phrase)은 오직 사람을 위한 설명이다.

- 100 Continue: (1xx) 클라이언트가 본문을 보내기 전, 헤더만 먼저 보내서 "이거 보내도 돼?" 물어볼 때 사용.
- 200 OK: (2xx) 성공. 가장 일반적.
- 301 Moved Permanently: (3xx) 리소스가 영원히 이사 감. 브라우저는 북마크를 갱신해야 함.
- 302 Found: (3xx) 리소스가 잠깐 이사 감. (대부분의 리다이렉트).
- 304 Not Modified: (3xx) 조건부 요청 시, "네가 가진 캐시랑 똑같으니 그거 써라"는 뜻. (본문 없음, 대역폭 절약).
- 401 Unauthorized: (4xx) 인증 필요 (로그인 해라).
- 403 Forbidden: (4xx) 서버가 요청을 거부함 (권한 없음, 파일 숨김 등).
- 405 Method Not Allowed: (4xx) 해당 URL에 그 메서드(예: DELETE)는 못 쓴다.
- 502 Bad Gateway: (5xx) 프락시나 게이트웨이가 업스트림 서버로부터 이상한 응답을 받음.

---

## 헤더 분류
헤더는 어디에 쓰이느냐에 따라 5가지로 나뉜다.
1. 일반 헤더 (General): 요청/응답 양쪽에 모두 쓰임. (예: Date, Connection)
2. 요청 헤더 (Request): 클라이언트 정보나 선호도. (예: User-Agent, Accept-Language)
3. 응답 헤더 (Response): 서버 정보. (예: Server, Retry-After)
4. 엔터티 헤더 (Entity): 본문(Payload)에 대한 설명. 본문이 없어도 있을 수 있음. (예: Content-Type, Content-Length)
5. 확장 헤더 (Extension): 표준에 없지만 개발자가 임의로 만든 헤더. (과거엔 X-를 붙였으나 요즘은 안 붙이는 추세)

---

## 오늘의 회고
1. 빈 줄(CRLF)의 역할: 헤더와 본문을 구분하는 것이 고작 '빈 줄' 하나라는 점이 HTTP의 단순함을 보여준다. 하지만 코딩할 때 이 빈 줄을 빠뜨리면 서버는 헤더가 계속되는 줄 알고 무한 대기할 수 있다.
2. 멱등성의 실무적 중요성: 네트워크 오류로 패킷이 유실됐을 때, 클라이언트가 자동으로 재시도(Retry) 해도 되는지 판단하는 기준이 바로 멱등성이다. POST 요청이 실패했을 때 함부로 재전송하면 중복 결제가 될 수 있으니 조심해야 한다는 원리를 깨달았다.
3. 304 Not Modified의 경제학: 이 코드는 본문 데이터를 보내지 않음으로써 인터넷 트래픽을 어마어마하게 절약해주는 일등 공신이다. 캐시 최적화의 핵심이다.

---                 

# 커넥션 관리

## TCP 커넥션의 이해
HTTP 메시지는 반드시 TCP 커넥션을 맺은 이후에 데이터를 보낼 수 있다. 따라서 HTTP 성능은 TCP 성능에 크게 좌우된다.

### TCP 커넥션의 지연 요소
웹 브라우저가 느리게 느껴지는 경우 대부분 지연 때문인 경우가 많다.
- TCP 핸드셰이크 지연:
  - 새로운 연결을 맺을 때 마다 `SYN` -> `SYN+ACK` -> `ACK`의 3-way handshake가 필요하다. 작은 데이터를 보낼 때도 이 과정이 필수라 오버헤드가 크다.
- TCP 느린 시작:
  - TCP는 처음에는 패킷을 천천히 보내다가 성공하면 속도를 높인다. (혼잡 제어)
  - 새로 맺은 커넥션은 튜닝되지 않아 속도가 느리다. 이미 튜닝된 커넥션을 사용하는게 중요하다.
- 네이글 알고리즘:
  - 작은 패킷 여러개을 모아서 한번에 보낸다. 효율적이지만, HTTP 처럼 요청-응답이 즉시 필요한 경우 지연을 유발한다.(HTTP는 `TCP_NODELAY`로 끈다.)
- TIME_WAIT 누적
  - 커넥션을 끊은 쪽에서 일정 시간 동안 포트를 점유하고 있는다. 커넥션을 너무 자주 맺고 끊으면 가용 포트가 고갈될 수 있다.

---

## HTTP 커넥션 관리 모델
초기 HTTP부터 현재까지 커넥션을 효율적으로 사용하기 위해 모델이 진화.

### 병렬 커넥션
- 방식: 브라우저가 여러 개의 TCP 커넥션(보통 6개)을 동시에 맺어 여러 이미지나 파일을 한꺼번에 내려받는다.
- 장점: 사용자가 보기에 페이지가 빨리 뜨는 것처럼 느껴진다.
- 단점: 서버 메모리를 많이 잡아먹고, 각 커넥션마다 핸드셰이크/느린 시작 비용이 발생한다.

### 지속 커넥션
- 방식: 처리가 완료된 커넥션을 끊지 않고, 계속 연결해 둔 상태로 다음 요청을 보낸다.
- 장점:
  - 핸드셰이크 시간 절약.
  - TCP "느린 시작" 단계를 건너뛰고 튜닝된 속도로 전송 가능.
- 종류:
  - HTTP/1.0+ Keep-Alive: 실험적인 모델. 헤더에 Connection: Keep-Alive를 명시해야 함.
  - HTTP/1.1 Persistent: 기본적으로 지속 커넥션. 끊으려면 Connection: close를 명시해야 함.

---

## Keep-Alive와 멍청한(Dumb)프락시 문제
HTTP/1.0의 `Keep-Alive` 설계에는 치명적인 결함이 있었다.

### 멍청한 프락시
1. 클라이언트가 `Connection: Keep-Alive` 헤더를 보내며 연결 유지를 요청함.
2. 중간에 있는 오래된 프락시는 이 헤더의 의미를 모른다.
3. 프락시는 이 헤더를 그대로 서버에 전달(Relay) 해버린다. (Hop-by-Hop 헤더는 전달하면 안 되는데 규칙을 모름).
4. 서버는 프락시가 연결 유지를 원하는 줄 알고 동의함.
5. 결과: 프락시는 통신이 끝난 줄 알고 기다리고(Hung), 서버는 프락시의 다음 요청을 기다리고, 클라이언트는 응답을 기다리는 무한 대기(Hang) 상태에 빠진다.

### 해결책: Proxy-Connection 헤더
이 문제를 피하기 위해 브라우저는 비표준인 `Proxy-Connection` 헤더를 사용하기도 한다. 멍청한 프락시는 이걸 그대로 넘기지만, 영리한 프락시는 이걸 보고 `Connection: Keep-Alive`로 바꿔서 서버에 보낸다.

---

## 파이프라인 커넥션
HTTP/1.1에서 지속 커넥션을 더 효율적으로 쓰기 위해 제안된 기술.

- 방식: 요청을 보내고 응답을 기다리지 않고, 연속해서 요청을 쏜다. (요청1 -> 요청2 -> 요청3 ... 응답1 -> 응답2 -> 응답3)
- 제약:
  - 응답은 반드시 요청 순서대로 와야 한다.
  - 중간에 하나가 막히면 뒤에 것도 다 막힌다 (HOL Blocking 문제).
  - 실무: 구현이 복잡하고 버그가 많아 실제로는 잘 안 쓰임 (HTTP/2에서 멀티플렉싱으로 해결됨).

---

## 커넥션 끊기
영원한 커넥션은 없다. 언제 어떻게 끊느냐가 중요하다.

- 우아한 종료 (Graceful Close):
  - TCP는 양방향 통신이다. 입력 채널과 출력 채널이 따로 있다.
  - 갑자기 close()를 부르면 전송 중이던 데이터가 유실될 수 있다.
  - 자신의 출력 채널만 먼저 닫고(shutdown), 상대방의 데이터가 다 올 때까지 기다리는 것이 안전하다.
- Content-Length의 중요성: 지속 커넥션에서는 메시지의 끝을 알아야 한다. Content-Length 값이 틀리면 커넥션은 다음 데이터를 하염없이 기다리거나, 다음 요청을 데이터로 착각하게 된다.

---

## 오늘의 회고
1. "이미 맺어진 커넥션이 가장 빠르다": 웹 최적화의 제1원칙은 불필요한 바이트를 줄이는 것이지만, 제2원칙은 기존 커넥션을 재활용하는 것이다. TCP 3-way handshake 비용이 생각보다 비싸다는 것을 깨달았다.
2. Hop-by-Hop 헤더의 위험성: Connection 헤더는 딱 나와 내 옆의 녀석(프락시) 사이에서만 유효하고 삭제되어야 한다. 이를 어기면 전체 통신이 마비될 수 있다는 '멍청한 프락시' 시나리오가 매우 흥미롭다.
3. HTTP/1.1의 위대함: HTTP/1.1이 단순히 기능 추가가 아니라, 1.0의 커넥션 관리 문제(성능 저하)를 해결하기 위해 '지속 커넥션'을 기본(Default)으로 채택했다는 점이 프로토콜 설계의 진화를 보여준다.

---

# 프록시

## 프록시란?

프록시는 클라이언트와 서버 사이의 중개자이다. HTTP 요청을 받아서 다른 서버로 전달하고, 응답을 받아 다시 클라이언트에게 돌려준다.

- 과거의 프록시: 주로 인터넷 속도를 높이기 위한 캐시 공유나, 사내망 접속 통제용으로 사용.
- 현대의 프록시: 보안, 부하 분산, 익명화, 트래픽 분산의 핵심 인프라.

---

## 프록시의 두 얼굴: Foward vs Reverse

책에서는 두 개념을 설명하지만, 현대 아키텍쳐에서는 리버스 프록시의 비중이 압도적으로 커졌다.

### 포워드 프록시 - 클라이언트 대리인
- 위치: 클라이언트 앞단에 위치.
- 역할: 클라이언트를 감춰준다.(서버는 요청이 프록시에서 온 줄 안다.)
- 용도:
  - 검열 우회 및 익명성
  - 사내 보안
  - 캐싱: (ISP 차원에서 대역폭 절약 - 현재는 CDN으로 대체)

### 리버스 프록시 - 서버 대리인
- 위치: 웹 서버 앞단에 위치.
- 역할: 진짜 서버를 감춘다.(클라이언트는 프록시가 서버인줄 알고 요청.)
- 대표적 소프트웨어: Nginx, HAProxy, AWS ALB, Traefik.
- 현대적 용도:
  - 로드 밸런싱: 들어오는 요청을 여러대의 뒷단 서버로 분산시킨다.
  - 보안(WAF): 디도스 공격을 막거나 SQL 인젝션을 필터링한다.
  - TLS 종단: 암호화/복호화 부하를 프록시가 담당하고, 뒷단 서버와는 가벼운 HTTP로 통신한다.

---

## 프록시와 헤더
프록시를 거치면 클라이언트 정보가 세탁될 수 있다. 이를 방지하기 위한 헤더 규약이 존재.

## X-Forwarded-For (XFF)와 표준화
프록시르 통과할 때마다 원본 IP가 사라진다. 이를 보오나하기 위해 헤더를 추가한다.
- 과거/관습: `X-Forwarded-For: <Client-IP>, <Proxy1-IP>, ...`
  - 이 헤더를 확인하지 않으면 서버는 모든 요청이 로드 밸런서 IP에서 온 것으로 착각한다.
- 최신 표준(RFC 7239): `Forwarded` 헤더
  - `Forwarded: for=192.0.2.60;proto=http;by=203.0.113.43` 형식으로 더 상세한 정보를 담는다. (하지만 여전히 실무에선 XFF가 더 많이 쓰임)

### Via 헤더
- 메시지가 거쳐간 프록시들의 경로를 기록한다. 무한 루프 방지용으로 사용.

---

## HTTPS와 프록시의 딜레마

책에서는 간단히 다루지만, 현재 웹의 90% 이상은 HTTPS다. 프락시는 암호화된 데이터를 어떻게 처리할까?

### HTTP CONNECT 메서드 (터널링)
- 클라이언트가 프락시에게 "나 저 서버랑 비밀 얘기(HTTPS) 할 거니까, 내용 보지 말고 파이프만 연결해줘"라고 요청한다.
- 프록시는 단순히 바이트를 퍼 나르기만 한다(Blind Relay). 내용을 볼 수 없다.

### MITM (Man-In-The-Middle) 프록시
- 회사 보안 장비나 개발용 프록시(Charles, Fiddler)는 HTTPS 내용을 뜯어봐야 한다.
- 원리: 프록시가 가짜 인증서를 만들어서 클라이언트에게 주고, 자기가 서버인 척한다. 클라이언트가 이를 신뢰(인증서 설치)해야만 가능하다.

---

## 마이크로서비스 시대의 프록시: Service Mesh

책에는 없지만 6장의 개념이 현대적으로 확장된 개념이다.

- 사이드카 패턴: 모든 애플리케이션 컨테이너 옆에 작은 프록시(Envoy 등)를 하나씩 붙인다.
- 역할:
  - 서비스 간 통신(Service-to-Service)을 프록시가 가로채서 처리한다.
  - 트래픽 제어: A버전 90%, B버전 10% 전송 (카나리 배포).
  - 서킷 브레이커: 뒷단 서비스가 죽으면 프록시 선에서 차단하여 장애 확산 방지.
  - 관측 가능성(Observability): 누가 누구를 호출했는지 자동으로 추적.

---

## 오늘의 회고
1. "진짜 IP"를 찾는 법: 백엔드 개발 시 `request.getRemoteAddr()`를 쓰면 사용자가 아닌 로드 밸런서의 IP가 찍힌다는 것을 명심해야 한다. 반드시 `X-Forwarded-For`의 첫 번째 값을 파싱하거나, 프레임워크의 신뢰할 수 있는 프록시 설정을 켜야 한다.
2. 프록시는 아키텍처의 유연함이다: 서버 구성을 바꿀 때 클라이언트를 수정할 필요 없이, 앞단의 리버스 프록시(Nginx 등) 설정만 바꾸면 된다는 점이 유지보수의 핵심이다.
3. TLS Offloading의 중요성: 암호화는 CPU를 많이 쓴다. 비싼 웹 서버 대신 앞단의 프록시 장비가 이를 전담하게 하여 웹 서버의 부하를 줄이는 전략이 대규모 서비스의 기본임을 알게 되었다.

---

# 웹 캐시

## 웹 캐시란?
- 정의: 자주 요청되는 리소스의 사본을 저장해 두었다가, 다음 요청부터는 원 서버가 아니라 캐시에서 바로 응답해 주는 HTTP 장치(브라우저 캐시, 프록시 캐시, CDN 등 포함).
- 효과
  - 불필요한 데이터 전송 감소 → 네트워크 비용 절감
  - 네트워크 병목 완화 → 체감 속도 개선
  - 원 서버 부하 감소 → 더 많은 요청을 처리 가능
  - 거리·지연 감소 → 지리적으로 먼 서버라도 빠르게 응답 가능

---

## 캐시 적중/부적중과 성능 지표
- 캐시 적중: 요청한 리소스가 캐시에 존재하여, 원 서버에 가지 않고 캐시에서 바로 응답.
- 캐기 부적중: 캐시에 리소스가 없거나, 쓸 수 없는 상태라서 원 서버에 요청.
- 중요 지표:
  - hit ratio: 전체 요청 중 캐시 적중 비율
  - byte hit ratio: 전체 전송 바이트 중 캐시가 대신 처리한 비율
  → 단순 응답 속도뿐만 아니라 바이트 기준으로도 캐시 효과를 보는것이 중요하다.

---

## 신선도 관리
서버가 언제까지 이 리소스를 믿어도 되는지를 클라이언트/캐시에게 알려주는 방식이다.

### 만료 관련 헤더
- Cache-Control: `max-age=초`
  - 문서가 생성된 시점부터 “최대 나이”를 정의
  - 예: `Cache-Control: max-age=31536000` → 1년 동안 신선한 리소스
- Expires: 날짜
  - 이 날짜/시간까지 유효함을 명시(HTTP/1.0 방식)
  - 예: `Expires: Wed, 21 Oct 2025 07:28:00 GMT`
- Age 헤더
  - 캐시가 응답할 때, 이 사본이 얼마나 오래되었는지(초 단위)를 알려줌

### 기타 Cache-Control 디렉티브
- `no-store`: 민감한 정보. 아예 디스크/메모리에 저장 금지.
- `no-cache` : 캐시에 저장은 할 수 있지만, 쓰기 전에 반드시 원 서버 재검사 필요.
- `must-revalidate` : 만료된 후에는 반드시 원 서버와 재검사해야 함.
- `public / private`
  - `public`: 중간 캐시(프록시)에도 저장해도 됨.
  - `private`: 브라우저 같은 개인 캐시에만 저장.

프론트/백엔드 개발시 기본적으로 `Cache-Control` 조합을 의식적으로 설계해야 한다.

---

## 재검사 기반 캐싱: 조건부 요청과 304
만료 시간만으로는 부족할 때, 바뀌었는지 확인만 하는 방식.

### Last-Modified / If-Modified-Since
- 서버 응답 예:
  - `Last-Modified: Wed, 21 Oct 2025 07:28:00 GMT`
- 다음 요청 시 브라우저가:
  - `If-Modified-Since: Wed, 21 Oct 2025 07:28:00 GMT`
- 서버 동작:
  - 변경 없음 → `304 Not Modified` + 헤더만 전송 (본문 없음)
  - 변경됨 → `200 OK` + 새로운 본문 전송

본문을 다시 받지 않고도 최신 여부만 확인 하는것이 포인트이다.

### ETag / If-None-Match
- ETag: 리소스 버전에 대한 고유 식별자(해시처럼 생각)
  - 응답: `ETag: "v1.2.3-abcd"`
- 다음 요청 시:
  - `If-None-Match: "v1.2.3-abcd"`
- 서버:
  - 동일 버전이면 `304 Not Modified`
  - 다르면 새 리소스 + 새 ETag

시간기반보다 더 정밀하게 변경 여부를 판단 가능하다.
실제 서비스에서 가장 많이 사용하는 패턴이다. `ETag + Cache-Control.`

---

## 캐시 전략과 캐시 무력화(Cache busting)

### 캐시 제어 전략
- 정적 자원(CSS, JS, 이미지)
  - 파일명에 해시 붙이고, `Cache-Control: max-age=1년, public, immutable` 같이 강하게 캐시
  - 변경 시 파일명(해시)이 바뀌므로, 자연스럽게 캐시 무효화
- HTML 문서
  - 상대적으로 짧은 `max-age` 또는 `no-cache + 조건부 요청`으로 신선도 유지
- API 응답
  - 변경 빈도, 데이터 민감도에 따라 `no-store, no-cache, max-age` 등 선택

### 캐시 무력화 방법
- 쿼리 스트링 버전: `/app.js?v=123`
- 파일명에 해시: `/app.1a2b3c.js`
- 응답 헤더로 아예 캐시를 막기: `Cache-Control: no-store`

---

## 캐시 처리 단계
캐시가 요청을 받았을 때 대략 이런 흐름으로 동작한다.:

1. 요청 도착 → 캐시 키 계산(URL, Host, Vary 헤더 등)
2. 로컬 캐시에서 엔트리 검색
3. 만료 여부/정책 확인
   - 신선하면 → 바로 응답(cache hit)
   - 신선하지 않으면 → 원 서버에 조건부 요청(If-Modified-Since / If-None-Match)
4. 원 서버 응답
   - 304면 → 캐시 헤더만 갱신 후 캐시에 있는 본문으로 응답
   - 200이면 → 새 리소스를 저장하고 응답
5. 로깅, 통계( hit ratio, latency 등)

단순히 저장해놨다가 요청이 오면 주는것이아니라 프로토콜단에서 꽤 복잡한 정책/과정을 통해 진행된다.

---

## 오늘의 회고
- 캐싱은 **속도 최적화뿐 아니라 비용/부하/지연까지 동시에 줄여주는 기본기**다.
- Cache-Control, Expires, Age로 **신선도(언제까지 믿을 수 있는지)** 를 표현한다.
- Last-Modified / If-Modified-Since, ETag / If-None-Match로 변경 여부를 재검사해 낭비를 줄인다.
- 정적 파일은 **파일명 버전 + 강한 max-age 조합**이 사실상 표준 패턴이다.
- 캐시 정책은 “어디에 캐시가 있는지(브라우저/프록시/CDN/리버스 프록시)”까지 포함해서 설계해야 한다.

---

# HTTP/2.0

## HTTP/2.0의 등장배경
HTTP/1.0의 구조적 한계때문에 등장하였다.
- HTTP/1.1의 한계
  - 텍스트 기반 + 요청/응답 순차 처리 구조 → 지연(latency) 큼
  - 하나의 TCP 커넥션에서 사실상 “요청 하나씩 처리” → HOL(Head-of-line) blocking
  - 이를 피하려고 브라우저가 병렬 커넥션 여러 개를 열지만 개수 제한이 있음
  - 요청마다 중복되는 헤더(쿠키, User-Agent 등) 계속 전송 → 낭비
- SPDY → HTTP/2로의 진화
  - 구글 SPDY가 헤더 압축, 하나의 TCP 연결에서 동시 요청 등으로 성능 개선 시도
  - 이 아이디어들을 기반으로 HTTP/2 초안이 작성되고, 2015년 HTTP/2 표준 공개
---

## HTTP/2.0 개요: 무엇이 달라졌나
문법은 거의 유지하였고, 전송 방식만 대폭 변경했다고 이해하면 편하다.
- 텍스트 → 바이너리 프로토콜
  - HTTP/1.1:
    - `GET /index.html HTTP/1.1` 같은 텍스트 줄을 파싱해야 했음
  - HTTP/2:
    - 모든 메시지를 바이너리 프레임(frame) 단위로 쪼개서 보냄
    - 사람이 읽기 어렵지만, 기계가 파싱하기 훨씬 빠르고 안전
- 프레임(Frame) 단위 전송
  - HTTP/2 메시지는 모두 프레임에 담겨 전송
  - 프레임 = 헤더(8바이트) + 페이로드(최대 16383바이트) 구조
  - 다양한 프레임 타입: `DATA, HEADERS, SETTINGS, PUSH_PROMISE, PING` 등
- 스트림(Stream)과 하나의 TCP 커넥션
  - 하나의 TCP 연결 위에서 여러 스트림을 동시에 운반
  - 각 스트림은 고유 ID + 독립된 양방향 시퀀스
  - 프레임에는 “이 프레임이 어느 스트림에 속하는지”를 나타내는 스트림 식별자(31비트) 가 포함

---

## HTTP/1.1과의 핵심 차이점

### 프레임 구조
프레임 헤더 필드:
- 길이(Length, 14비트): 페이로드 길이
- 종류(Type, 8비트): DATA, HEADERS, … 어떤 프레임인지
- 플래그(Flags, 8비트): END_STREAM, END_HEADERS 등 속성
- R(Reserved): 예약 비트(항상 0)
- 스트림 식별자(Stream Identifier, 31비트)

→ 이 구조 덕분에 프레임을 조합하여 메시지를 만들고, 다양한 제어 기능(우선순위, 흐름 제어 등)을 구현 가능.

### 스트림과 멀티 플렉싱
- 멀티플렉싱: 하나의 TCP 커넥션에서 여러 요청/응답이 동시에 오가게 하는 핵심 기능이다.
- 장점
  - HOL blocking 완화 (어느 정도)
  - 커넥션 수를 무리하게 늘릴 필요 줄어듦
  - RTT(왕복 지연) 영향 완화 → 체감 성능 개선
- 우선순위, 흐름 제어(Flow Control)도 지원한다.
  - 각 스트림에 우선순위를 부여해 중요한 리소스를 먼저 보내도록 힌트 제공 가능.
  - 단, 우선순위는 권고 사항이기 때문에 실제 서버 구현에 따라 효과는 다를 수 있다.

### 헤더 압축
HTTP/1.1은 매 요청마다 비슷한 헤더(쿠키, User-Agent 등)를 계속 보내서 비효율적.

HTTP/2는 HPACK이라는 전용 헤더 압축 알고리즘을 도입:
- 정적 테이블: 자주 쓰이는 표준 헤더를 미리 정의해두고 인덱스로 전송
- 동적 테이블: 세션 중에 자주 사용하는 헤더를 테이블에 쌓아두고 재사용
- 요청/응답 양쪽이 압축 컨텍스트(context) 를 공유 → 헤더를 조각 내어 압축/복원

장점:
  - 헤더크기 대폭 감소 → 대역폭 절감, 지연 감소
  - 잘못된 압축 상태 등 문제 발생시 `COMPRESSION_ERROR`로 명확히 실패 처리

---

## 서버 푸시
- HTTP/1.1: 클라이언트가 요청해야만 서버가 응답 가능
- HTTP/2: 서버가 “이 HTML이면 CSS/JS도 필요하겠네?” 하고 먼저 보내줄 수 있음
  - `PUSH_PROMISE` 프레임으로 “이 리소스를 곧 보낼게”라고 선 선언
  - 그 후 해당 리소스를 실제 DATA 프레임으로 푸시
- 장점:
  - RTT를 줄여 초기 로딩 속도 개선 가능(잘 설계했을 경우)
- 단점/주의:
  - 남용 시 불필요한 리소스 전송 → 오히려 느려질 수 있음
  - 현대 브라우저/플랫폼에서는 서버 푸시 활용이 제한적이거나 비권장인 경우도 많음(실무에서는 CDN/플랫폼 가이드 체크 필요)

--- 

## 보안 이슈
책에서 언급하는 대표적인 HTTP/2 관련 보안 이슈들:

1. 중계자 캡슐화 공격 (Intermediary Encapsulation Attack)
   - HTTP/2 메시지가 중간 프록시/게이트웨이에서 HTTP/1.1로 변환될 때
의미가 변질될 수 있는 문제
   - HTTP/2는 헤더를 바이너리로 인코딩하고, 중간 장비는 HTTP/1.1 텍스트 헤더로 번역
   - 이 과정에서 잘못된 해석 →
정상 요청이 위조/변조된 것처럼 보이거나, 반대로 악성 요청이 정상으로 보일 위험

2. 장기 커넥션에 따른 개인정보 노출 가능성
   - 지연 감소를 위해 클라이언트–서버 사이 커넥션을 오래 유지하는 특성이 있음
   - 이 장기 커넥션이 사용자 추적/식별에 악용될 여지가 있음
(이전 방문 기록, 세션 정보 등의 노출 가능성 증가)

→ 성능을 위해 연결을 오래 유지하고, 더 많은 정보를 한 연결에서 주고받는 만큼,
프록시/게이트웨이 설계와 개인정보 보호 관점에서 더 신경 써야 한다는 메시지.

---

## 오늘의 회고
- HTTP/2는 HTTP의 의미(메서드, 상태 코드)를 유지한 채, 전송 방식을 바이너리 프레임/스트림 기반으로 바꿔 성능과 효율을 올린 버전이다.
- 하나의 TCP 커넥션에서 여러 스트림을 멀티플렉싱하여 HOL blocking을 완화한다.
- HPACK 헤더 압축으로 중복 헤더를 크게 줄여 대역폭과 지연을 줄인다.
- 서버 푸시(Server Push) 로 서버가 필요한 리소스를 먼저 보낼 수 있지만, 남용하면 역효과가 날 수 있다.
- HTTP/2는 중계자 캡슐화 공격, 장기 커넥션에 따른 개인정보 노출 같은 새로운 보안 이슈도 가지고 있어 인프라 설계 시 주의가 필요하다.