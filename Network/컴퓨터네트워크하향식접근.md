> 컴퓨터 네트워크 하향식 접근 책을 읽고 정리한 내용입니다.

# Ch 1. Computer Networks and the Internet (컴퓨터 네트워크와 인터넷)

> 큰 흐름: **Internet (인터넷)** 은 전 세계의 **End System (종단 시스템, 호스트)** 들이 **Communication Link (통신 링크)** 와 **Packet Switch (패킷 스위치: 라우터/스위치)** 로 연결된 “network of networks (네트워크들의 네트워크)” 이다. 핵심은 **Packet Switching (패킷 교환)**, **Protocol (프로토콜)**, **Layered Architecture (계층 구조)** 로 복잡도를 제어하면서, 지연/손실/처리율 같은 성능 지표를 이해하고 **Security (보안)** 과 **Application 요구사항** 까지 함께 보는 것이다.

---

## 1. What Is the Internet? (인터넷이란?)

### 1.1 구성요소 관점 (nuts-and-bolts view)

* **Host / End System (호스트/종단 시스템)**: PC, 서버, 스마트폰, IoT 등 네트워크의 “끝단”.
* **Communication Link (통신 링크)**: 광섬유, 동축, 구리선, 무선 등. 링크의 전송률은 **Transmission Rate / Bandwidth (전송률/대역폭, bps)** 로 표현.
* **Packet Switch (패킷 스위치)**: **Router (라우터)**, **Link-layer Switch (링크 계층 스위치)**. 패킷을 받아 다음 홉으로 전달(**Forwarding**)하고 경로를 선택(**Routing**)한다.
* **Packet (패킷)**: 데이터가 네트워크를 이동할 때 쪼개지는 단위(헤더 + 페이로드).
* **ISP (Internet Service Provider, 인터넷 서비스 제공자)**: 가정/기업/모바일 사용자를 인터넷에 연결하고, ISP들끼리도 계층적으로 연결된다.

### 1.2 서비스 관점 (service view)

* 인터넷은 애플리케이션에 **Communication Service (통신 서비스)** 를 제공한다.
* 앱은 **Socket (소켓)** 을 통해 네트워크로 데이터를 주고받는다.
* 대표 서비스 모델:

  * **TCP (Transmission Control Protocol)**: 연결지향, 신뢰적 전달, 혼잡제어.
  * **UDP (User Datagram Protocol)**: 비연결, 단순/빠름, 신뢰성은 앱이 책임.

### 1.3 프로토콜이란? (What is a protocol?)

* **Protocol (프로토콜)**: 메시지 형식, 주고받는 순서, 이벤트 발생 시 동작을 규정.
* 사람이 인사 규칙을 따르듯, 네트워크도 프로토콜로 상호운용성을 확보한다.

---

## 2. Network Edge (네트워크의 가장자리)

### 2.1 Access Network (접속 네트워크)

* 사용자가 ISP에 붙는 “마지막 구간”.
* 예시:

  * **DSL (Digital Subscriber Line)**, **Cable (케이블)**, **FTTH (Fiber To The Home)**
  * **Ethernet (이더넷)**, **Wi-Fi**
  * **Cellular (셀룰러: 4G/5G)**

### 2.2 Physical Media (물리 매체)

* **Guided Media (유선 매체)**: 꼬임선, 동축, 광섬유
* **Unguided Media (무선 매체)**: 전파/마이크로웨이브/위성 등
* 매체 특성은 대역폭, 잡음, 감쇠, 간섭 등에 영향을 준다.

---

## 3. Network Core (네트워크의 중심)

### 3.1 Packet Switching (패킷 교환)

* 데이터를 패킷으로 쪼개 각 패킷이 네트워크를 통과.
* 라우터는 일반적으로 **Store-and-Forward (저장 후 전달)**: 한 링크로 들어온 패킷을 저장한 후 다음 링크로 송신.
* **Queueing (큐잉)**: 출력 링크가 바쁘면 버퍼에서 대기 → 지연 증가.
* **Loss (손실)**: 버퍼가 가득 차면 패킷 드롭.

### 3.2 Circuit Switching (회선 교환)과 비교

* **Circuit Switching (회선 교환)**: 통신 전에 자원을 예약(대역폭/타임슬롯). 지연 예측이 쉽지만 유휴 시간에도 자원을 점유 → 비효율 가능.
* **Packet Switching**: 통계적 다중화(**Statistical Multiplexing**)로 평균 효율이 높지만, 혼잡 시 지연/손실 변동이 커질 수 있다.

### 3.3 Delay, Loss, Throughput (지연/손실/처리율)

* 노드에서의 지연 구성:

  * **Processing Delay (처리 지연)**: 헤더 검사, 오류 체크 등
  * **Queueing Delay (큐잉 지연)**: 버퍼 대기
  * **Transmission Delay (전송 지연)**: 패킷을 링크에 “밀어 넣는” 시간 = `L/R` (L=비트 길이, R=전송률)
  * **Propagation Delay (전파 지연)**: 신호가 매체를 따라 이동 = `d/s` (d=거리, s=전파속도)
* **End-to-End Delay (종단간 지연)**: 위 요소들의 합(경로상의 여러 홉 포함).
* **Throughput (처리율)**:

  * **Instantaneous Throughput (순간 처리율)** vs **Average Throughput (평균 처리율)**
  * 전체 경로는 보통 **Bottleneck Link (병목 링크)** 가 처리율을 제한.

---

## 4. Protocol Layers and Service Models (프로토콜 계층과 서비스 모델)

### 4.1 Layering (계층화)의 목적

* 복잡한 시스템을 계층으로 나눠 **모듈화**, **표준화**, **교체 용이성** 확보.
* 각 계층은 아래 계층의 서비스를 이용하고, 위 계층에 서비스를 제공한다.

### 4.2 Internet Protocol Stack (인터넷 5계층 스택)

* **Application Layer (응용 계층)**: HTTP, DNS, SMTP 등
* **Transport Layer (전송 계층)**: TCP, UDP
* **Network Layer (네트워크 계층)**: IP, 라우팅
* **Link Layer (링크 계층)**: Ethernet, Wi-Fi, LTE 링크 등
* **Physical Layer (물리 계층)**: 비트 신호 전송

### 4.3 Encapsulation (캡슐화)

* 상위 계층 데이터에 하위 계층 헤더(그리고 경우에 따라 트레일러)가 붙으며 내려감.
* 수신 측에서는 역순으로 헤더를 벗기며(**Decapsulation**) 처리.

### 4.4 OSI Model (OSI 7계층)과의 관계

* OSI는 7계층 참조모델(표현/세션 포함)로 교육적 의미가 크고,
* 실제 인터넷은 5계층 스택 중심으로 설명하는 경우가 많다.

---

## 5. Networks Under Attack (공격받는 네트워크)

### 5.1 대표 공격/위협

* **Malware (악성코드)**: 바이러스, 웜, 트로이목마, 랜섬웨어 등
* **DoS/DDoS (서비스 거부 공격)**: 대량 트래픽/요청으로 서비스 마비
* **Packet Sniffing (패킷 도청)**: 공유 매체/취약 구간에서 트래픽 엿보기
* **IP Spoofing (IP 스푸핑)**: 출발지 주소 위조

### 5.2 방어의 큰 방향

* **Authentication (인증)**, **Confidentiality (기밀성: 암호화)**, **Integrity (무결성)**, **Availability (가용성)**
* 네트워크는 “처음부터 신뢰”가 아니라, 설계/운영 전반에서 보안을 고려해야 한다.

---

## 6. Summary (요약)

* 인터넷은 **호스트-링크-라우터-ISP** 로 이루어진 거대한 **네트워크들의 네트워크**이며, **프로토콜**로 동작한다.
* **패킷 교환**은 통계적 다중화로 효율적이지만 혼잡 시 **지연/손실**이 발생한다(회선 교환과 대비).
* 성능은 **처리/큐잉/전송/전파 지연**, **손실**, **처리율(병목)** 로 분석한다.
* **계층 구조(5계층)** 와 **캡슐화** 는 복잡도를 낮추고 상호운용성을 만든다.
* 현실의 인터넷은 항상 공격 표면을 가지므로, 기본 위협(DoS, 스니핑, 스푸핑, 멀웨어)을 알고 방어 목표를 이해해야 한다.

# Ch 2. Application Layer (애플리케이션 계층)

> 큰 흐름: **Application Layer (애플리케이션 계층)** 은 네트워크 앱이 **End System (종단 시스템)** 위에서 동작하도록 **Application Protocol (애플리케이션 프로토콜)** 을 정의한다. 핵심은 **Client–Server / P2P (클라이언트–서버 / P2P)** 구조, **Socket API (소켓 인터페이스)**, **Transport Service 요구사항(신뢰성/지연/처리율/보안)**, 그리고 대표 프로토콜인 **HTTP, DNS, Email(SMTP/IMAP/POP3)**, **CDN** 개념이다.

---

## 1. Principles of Network Applications (네트워크 애플리케이션의 원리)

### 1.1 Application Architecture (애플리케이션 구조)

* **Client–Server Architecture (클라이언트–서버 구조)**

  * 항상 켜져 있는 **Server (서버)** 가 고정 주소(또는 안정적인 도메인)를 가진다.
  * **Client (클라이언트)** 는 서버에 접속 요청을 보내고 서비스를 받는다.
  * 예: 웹, 이메일(서버 기반), 클라우드 서비스.
* **Peer-to-Peer (P2P) Architecture (피어-투-피어 구조)**

  * 피어가 클라이언트이면서 서버 역할도 수행.
  * 확장성(피어가 늘수록 자원도 늘 수 있음)이 장점이지만 관리/보안/NAT 문제 등 복잡도가 증가.
  * 예: 일부 파일 공유/분산 앱.
* **Hybrid (혼합형)**

  * 로그인/검색은 서버, 데이터 전송은 P2P 등 혼합 설계가 흔하다.

### 1.2 Process Communicating (프로세스 통신)

* 네트워크 앱은 여러 **Process (프로세스)** 가 서로 메시지를 주고받는다.
* 동일 호스트 내부는 IPC로 충분하지만, 다른 호스트 간 통신은 네트워크가 필요.

### 1.3 Sockets (소켓)

* **Socket (소켓)**: 애플리케이션이 네트워크로 데이터를 주고받는 “문(door)”.
* 앱은 소켓에 데이터를 **send/receive** 하고, 아래 계층(전송/네트워크)이 실제 전달을 담당.

### 1.4 Addressing (주소 지정)

* 프로세스를 식별하려면 보통:

  * **IP Address (IP 주소)**: 호스트 식별
  * **Port Number (포트 번호)**: 호스트 내 프로세스(서비스) 식별

---

## 2. Transport Services the Application Needs (전송 계층 서비스 요구사항)

### 2.1 데이터 전달 관점

* **Reliable Data Transfer (신뢰적 전송)**

  * 데이터 손실이 허용되지 않는 앱(파일 전송, 이메일, 웹 페이지의 기본 전송 등)은 신뢰성이 중요.
* **Throughput (처리율/대역 요구)**

  * 일정 이상의 처리율이 필요(스트리밍 고화질, 대용량 전송 등)할 수 있음.
  * 반대로 “최소 처리율 보장”이 없더라도 적응형 비트레이트처럼 앱이 적응할 수도 있다.
* **Timing / Delay (지연 요구)**

  * 실시간성(VoIP, 온라인 게임)은 낮은 지연이 중요.
* **Security (보안)**

  * **Confidentiality (기밀성)**, **Integrity (무결성)**, **Authentication (인증)** 등이 필요할 수 있음.
  * 전송 계층 위의 **TLS** 같은 방식으로 제공되는 경우가 많다.

### 2.2 Internet Transport Protocols (인터넷 전송 프로토콜)

* **TCP (Transmission Control Protocol)**

  * 연결지향, 신뢰적 전송, 혼잡 제어.
  * 바이트 스트림 기반(메시지 경계는 앱이 관리).
* **UDP (User Datagram Protocol)**

  * 비연결, 신뢰성/순서 보장 없음, 오버헤드가 작음.
  * 메시지(데이터그램) 단위.

---

## 3. Web and HTTP (웹과 HTTP)

### 3.1 Web Basics (웹의 기본)

* **Web Page (웹 페이지)** 는 여러 **Object (오브젝트)** 로 구성(HTML, 이미지, JS, CSS 등).
* 각 오브젝트는 **URL** 로 식별된다.

### 3.2 HTTP Overview (HTTP 개요)

* **HTTP (HyperText Transfer Protocol)**: 웹의 대표 **Application Protocol**.
* **Client (브라우저)** 가 **HTTP Request**, **Server (웹 서버)** 가 **HTTP Response**.
* **Stateless (무상태)**: 서버는 기본적으로 클라이언트의 “이전 요청 상태”를 저장하지 않는다.

### 3.3 Persistent vs Non-persistent Connections (지속/비지속 연결)

* **Non-persistent HTTP (비지속 HTTP)**

  * 오브젝트마다 TCP 연결을 새로 맺고 끊는 방식.
  * 지연/오버헤드 증가.
* **Persistent HTTP (지속 HTTP)**

  * 하나의 TCP 연결을 유지하며 여러 오브젝트를 연속 요청.
  * 성능 개선(연결 설정 비용 감소).

### 3.4 HTTP Message Format (HTTP 메시지 형식)

* **Request Message**: 요청 라인(method, URL path, version) + 헤더들 + (옵션) 바디

  * 대표 메서드: **GET, POST, HEAD, PUT, DELETE** 등
* **Response Message**: 상태 라인(status code) + 헤더들 + 바디

  * 대표 상태코드: **200 OK, 301 Moved Permanently, 400 Bad Request, 404 Not Found, 505 HTTP Version Not Supported** 등

### 3.5 Cookies (쿠키)와 상태 유지

* HTTP는 무상태지만, 로그인/세션 같은 상태를 위해 **Cookie (쿠키)** 를 사용.
* 쿠키로 사용자 식별자를 저장하면 서버는 그 식별자로 사용자 상태를 간접적으로 관리 가능.

### 3.6 Web Caching (웹 캐싱)

* **Web Cache / Proxy (웹 캐시/프록시)**: 원 서버 대신 자주 요청되는 오브젝트를 저장해 제공.
* 장점: 응답 시간 감소, 백본/서버 부하 감소.
* **Conditional GET (조건부 GET)** 같은 기법으로 최신성 검증을 한다.

---

## 4. Electronic Mail (전자 메일)

### 4.1 Email System Components (이메일 시스템 구성)

* **User Agent (사용자 에이전트)**: 사용자가 메일을 읽고 쓰는 클라이언트.
* **Mail Server (메일 서버)**: 메일박스 관리/전달.
* **SMTP (Simple Mail Transfer Protocol)**: 메일 서버 간(또는 클라이언트→서버) 메일 전송.

### 4.2 SMTP 특징

* 기본적으로 **push (푸시)** 방식(보내는 쪽이 밀어 넣는다).
* 메시지 본문은 전통적으로 ASCII 기반이며, 첨부는 보통 **MIME** 로 처리.

### 4.3 Mail Access Protocols (메일 접근 프로토콜)

* 수신자가 서버에서 메일을 가져오거나 동기화:

  * **POP3**: 단순 다운로드 중심
  * **IMAP**: 서버에 메일을 두고 폴더/동기화 지원
  * (현실에선 HTTP 기반 웹메일도 흔함)

---

## 5. DNS (Domain Name System)

> DNS는 ‘인터넷의 전화번호부’ 역할: **Host Name (호스트 이름)** 을 **IP Address** 로 변환한다.

### 5.1 DNS 제공 기능

* **Name-to-IP Translation (이름→IP 변환)**
* **Host Aliasing (호스트 별칭)**: canonical name ↔ alias name
* **Mail Server Aliasing (메일 서버 별칭)**
* **Load Distribution (부하 분산)**: 여러 IP를 반환해 트래픽 분산

### 5.2 DNS 구조: 분산/계층 데이터베이스

* 단일 중앙 DB가 아니라, 확장성과 관리성을 위해 **Hierarchical (계층적)** + **Distributed (분산)**.
* 대표 계층:

  * **Root DNS Servers (루트 DNS)**
  * **TLD DNS Servers (최상위 도메인 DNS)**
  * **Authoritative DNS Servers (권한 DNS)**
* 조직/ISP는 보통 **Local DNS Resolver (로컬 DNS 리졸버)** 를 통해 질의한다.

### 5.3 DNS Query (DNS 질의)

* **Recursive Query (재귀 질의)**: 리졸버가 결과를 끝까지 받아 사용자에게 전달.
* **Iterative Query (반복 질의)**: 다음에 물어볼 서버 정보를 받아가며 순차 탐색.

### 5.4 DNS Caching (DNS 캐싱)

* 질의 결과를 일정 시간(**TTL**) 저장해 지연과 트래픽을 줄인다.
* 캐시로 인해 변경 전파가 즉시 반영되지 않을 수 있다.

### 5.5 DNS Records (DNS 레코드)

* 일반적으로 (Name, Value, Type, TTL) 형태.
* 대표 타입:

  * **A**: hostname → IPv4
  * **AAAA**: hostname → IPv6
  * **NS**: 도메인의 권한 DNS 서버
  * **CNAME**: 별칭 → 정식 이름
  * **MX**: 메일 서버

---

## 6. Peer-to-Peer Applications (P2P 애플리케이션)

### 6.1 P2P의 특징

* 서버 의존도를 줄이고 피어들이 자원을 제공.
* 장점: 확장성, 비용 분산 가능
* 단점: 피어 가용성 변동, NAT/방화벽 이슈, 보안/신뢰 문제

### 6.2 File Distribution 관점

* 전통적 클라이언트–서버는 서버 업로드가 병목이 되기 쉽다.
* P2P는 피어가 늘면 전체 업로드 자원도 늘어 분배 시간이 줄어들 수 있다(이상적인 경우).

---

## 7. Video Streaming and CDNs (비디오 스트리밍과 CDN)

### 7.1 스트리밍의 기본 이슈

* 네트워크 처리율 변동, 지연, 손실로 인해 끊김이 발생할 수 있음.
* 해결 방향: 버퍼링, 적응형 비트레이트 등.

### 7.2 CDN (Content Delivery Network)

* 전 세계에 분산된 서버에 콘텐츠를 복제해 사용자와 가까운 곳에서 제공.
* 목표: 지연 감소, 트래픽 분산, 원 서버 부하 감소.
* DNS를 이용해 “가까운/적절한” CDN 노드로 유도하는 방식이 흔하다.

---

## 8. Socket Programming with UDP and TCP (UDP/TCP 소켓 프로그래밍 개요)

### 8.1 UDP 소켓

* 비연결: 송신은 바로 send, 수신은 recv.
* 신뢰성/순서/재전송은 앱이 필요 시 구현.

### 8.2 TCP 소켓

* 연결지향: **3-way handshake** 로 연결 설정 후 데이터 송수신.
* 서버는 보통:

  * **Welcome Socket** 으로 연결 요청을 받고,
  * 연결마다 별도 소켓을 만들어 다중 클라이언트를 처리.

---

## 9. Summary (요약)

* 애플리케이션 계층은 **앱 구조(클라-서버/P2P)** 와 **프로토콜(HTTP/DNS/Email)** 로 인터넷 서비스를 만든다.
* 앱은 **소켓** 을 통해 전송 계층 서비스를 사용하며, 요구사항(신뢰성/지연/처리율/보안)에 따라 **TCP/UDP** 를 선택한다.
* 웹은 **HTTP(무상태)** 를 기반으로 하며, **지속 연결, 쿠키, 캐싱** 으로 성능/상태 문제를 해결한다.
* DNS는 분산 계층 구조로 **이름→IP 변환**, 캐싱(TTL), 레코드 타입(A/AAAA/NS/CNAME/MX) 등을 제공한다.
* 스트리밍은 처리율 변동을 다루기 위해 버퍼링/적응을 사용하고, **CDN** 으로 지연과 부하를 줄인다.
