> 컴퓨터 네트워크 하향식 접근 책을 읽고 정리한 내용입니다.

# Ch 1. Computer Networks and the Internet (컴퓨터 네트워크와 인터넷)

> 큰 흐름: **Internet (인터넷)** 은 전 세계의 **End System (종단 시스템, 호스트)** 들이 **Communication Link (통신 링크)** 와 **Packet Switch (패킷 스위치: 라우터/스위치)** 로 연결된 “network of networks (네트워크들의 네트워크)” 이다. 핵심은 **Packet Switching (패킷 교환)**, **Protocol (프로토콜)**, **Layered Architecture (계층 구조)** 로 복잡도를 제어하면서, 지연/손실/처리율 같은 성능 지표를 이해하고 **Security (보안)** 과 **Application 요구사항** 까지 함께 보는 것이다.

---

## 1. What Is the Internet? (인터넷이란?)

### 1.1 구성요소 관점 (nuts-and-bolts view)

- **Host / End System (호스트/종단 시스템)**: PC, 서버, 스마트폰, IoT 등 네트워크의 “끝단”.
- **Communication Link (통신 링크)**: 광섬유, 동축, 구리선, 무선 등. 링크의 전송률은 **Transmission Rate / Bandwidth (전송률/대역폭, bps)** 로 표현.
- **Packet Switch (패킷 스위치)**: **Router (라우터)**, **Link-layer Switch (링크 계층 스위치)**. 패킷을 받아 다음 홉으로 전달(**Forwarding**)하고 경로를 선택(**Routing**)한다.
- **Packet (패킷)**: 데이터가 네트워크를 이동할 때 쪼개지는 단위(헤더 + 페이로드).
- **ISP (Internet Service Provider, 인터넷 서비스 제공자)**: 가정/기업/모바일 사용자를 인터넷에 연결하고, ISP들끼리도 계층적으로 연결된다.

### 1.2 서비스 관점 (service view)

- 인터넷은 애플리케이션에 **Communication Service (통신 서비스)** 를 제공한다.
- 앱은 **Socket (소켓)** 을 통해 네트워크로 데이터를 주고받는다.
- 대표 서비스 모델:

  - **TCP (Transmission Control Protocol)**: 연결지향, 신뢰적 전달, 혼잡제어.
  - **UDP (User Datagram Protocol)**: 비연결, 단순/빠름, 신뢰성은 앱이 책임.

### 1.3 프로토콜이란? (What is a protocol?)

- **Protocol (프로토콜)**: 메시지 형식, 주고받는 순서, 이벤트 발생 시 동작을 규정.
- 사람이 인사 규칙을 따르듯, 네트워크도 프로토콜로 상호운용성을 확보한다.

---

## 2. Network Edge (네트워크의 가장자리)

### 2.1 Access Network (접속 네트워크)

- 사용자가 ISP에 붙는 “마지막 구간”.
- 예시:

  - **DSL (Digital Subscriber Line)**, **Cable (케이블)**, **FTTH (Fiber To The Home)**
  - **Ethernet (이더넷)**, **Wi-Fi**
  - **Cellular (셀룰러: 4G/5G)**

### 2.2 Physical Media (물리 매체)

- **Guided Media (유선 매체)**: 꼬임선, 동축, 광섬유
- **Unguided Media (무선 매체)**: 전파/마이크로웨이브/위성 등
- 매체 특성은 대역폭, 잡음, 감쇠, 간섭 등에 영향을 준다.

---

## 3. Network Core (네트워크의 중심)

### 3.1 Packet Switching (패킷 교환)

- 데이터를 패킷으로 쪼개 각 패킷이 네트워크를 통과.
- 라우터는 일반적으로 **Store-and-Forward (저장 후 전달)**: 한 링크로 들어온 패킷을 저장한 후 다음 링크로 송신.
- **Queueing (큐잉)**: 출력 링크가 바쁘면 버퍼에서 대기 → 지연 증가.
- **Loss (손실)**: 버퍼가 가득 차면 패킷 드롭.

### 3.2 Circuit Switching (회선 교환)과 비교

- **Circuit Switching (회선 교환)**: 통신 전에 자원을 예약(대역폭/타임슬롯). 지연 예측이 쉽지만 유휴 시간에도 자원을 점유 → 비효율 가능.
- **Packet Switching**: 통계적 다중화(**Statistical Multiplexing**)로 평균 효율이 높지만, 혼잡 시 지연/손실 변동이 커질 수 있다.

### 3.3 Delay, Loss, Throughput (지연/손실/처리율)

- 노드에서의 지연 구성:

  - **Processing Delay (처리 지연)**: 헤더 검사, 오류 체크 등
  - **Queueing Delay (큐잉 지연)**: 버퍼 대기
  - **Transmission Delay (전송 지연)**: 패킷을 링크에 “밀어 넣는” 시간 = `L/R` (L=비트 길이, R=전송률)
  - **Propagation Delay (전파 지연)**: 신호가 매체를 따라 이동 = `d/s` (d=거리, s=전파속도)

- **End-to-End Delay (종단간 지연)**: 위 요소들의 합(경로상의 여러 홉 포함).
- **Throughput (처리율)**:

  - **Instantaneous Throughput (순간 처리율)** vs **Average Throughput (평균 처리율)**
  - 전체 경로는 보통 **Bottleneck Link (병목 링크)** 가 처리율을 제한.

---

## 4. Protocol Layers and Service Models (프로토콜 계층과 서비스 모델)

### 4.1 Layering (계층화)의 목적

- 복잡한 시스템을 계층으로 나눠 **모듈화**, **표준화**, **교체 용이성** 확보.
- 각 계층은 아래 계층의 서비스를 이용하고, 위 계층에 서비스를 제공한다.

### 4.2 Internet Protocol Stack (인터넷 5계층 스택)

- **Application Layer (응용 계층)**: HTTP, DNS, SMTP 등
- **Transport Layer (전송 계층)**: TCP, UDP
- **Network Layer (네트워크 계층)**: IP, 라우팅
- **Link Layer (링크 계층)**: Ethernet, Wi-Fi, LTE 링크 등
- **Physical Layer (물리 계층)**: 비트 신호 전송

### 4.3 Encapsulation (캡슐화)

- 상위 계층 데이터에 하위 계층 헤더(그리고 경우에 따라 트레일러)가 붙으며 내려감.
- 수신 측에서는 역순으로 헤더를 벗기며(**Decapsulation**) 처리.

### 4.4 OSI Model (OSI 7계층)과의 관계

- OSI는 7계층 참조모델(표현/세션 포함)로 교육적 의미가 크고,
- 실제 인터넷은 5계층 스택 중심으로 설명하는 경우가 많다.

---

## 5. Networks Under Attack (공격받는 네트워크)

### 5.1 대표 공격/위협

- **Malware (악성코드)**: 바이러스, 웜, 트로이목마, 랜섬웨어 등
- **DoS/DDoS (서비스 거부 공격)**: 대량 트래픽/요청으로 서비스 마비
- **Packet Sniffing (패킷 도청)**: 공유 매체/취약 구간에서 트래픽 엿보기
- **IP Spoofing (IP 스푸핑)**: 출발지 주소 위조

### 5.2 방어의 큰 방향

- **Authentication (인증)**, **Confidentiality (기밀성: 암호화)**, **Integrity (무결성)**, **Availability (가용성)**
- 네트워크는 “처음부터 신뢰”가 아니라, 설계/운영 전반에서 보안을 고려해야 한다.

---

## 6. Summary (요약)

- 인터넷은 **호스트-링크-라우터-ISP** 로 이루어진 거대한 **네트워크들의 네트워크**이며, **프로토콜**로 동작한다.
- **패킷 교환**은 통계적 다중화로 효율적이지만 혼잡 시 **지연/손실**이 발생한다(회선 교환과 대비).
- 성능은 **처리/큐잉/전송/전파 지연**, **손실**, **처리율(병목)** 로 분석한다.
- **계층 구조(5계층)** 와 **캡슐화** 는 복잡도를 낮추고 상호운용성을 만든다.
- 현실의 인터넷은 항상 공격 표면을 가지므로, 기본 위협(DoS, 스니핑, 스푸핑, 멀웨어)을 알고 방어 목표를 이해해야 한다.

# Ch 2. Application Layer (애플리케이션 계층)

> 큰 흐름: **Application Layer (애플리케이션 계층)** 은 네트워크 앱이 **End System (종단 시스템)** 위에서 동작하도록 **Application Protocol (애플리케이션 프로토콜)** 을 정의한다. 핵심은 **Client–Server / P2P (클라이언트–서버 / P2P)** 구조, **Socket API (소켓 인터페이스)**, **Transport Service 요구사항(신뢰성/지연/처리율/보안)**, 그리고 대표 프로토콜인 **HTTP, DNS, Email(SMTP/IMAP/POP3)**, **CDN** 개념이다.

---

## 1. Principles of Network Applications (네트워크 애플리케이션의 원리)

### 1.1 Application Architecture (애플리케이션 구조)

- **Client–Server Architecture (클라이언트–서버 구조)**

  - 항상 켜져 있는 **Server (서버)** 가 고정 주소(또는 안정적인 도메인)를 가진다.
  - **Client (클라이언트)** 는 서버에 접속 요청을 보내고 서비스를 받는다.
  - 예: 웹, 이메일(서버 기반), 클라우드 서비스.

- **Peer-to-Peer (P2P) Architecture (피어-투-피어 구조)**

  - 피어가 클라이언트이면서 서버 역할도 수행.
  - 확장성(피어가 늘수록 자원도 늘 수 있음)이 장점이지만 관리/보안/NAT 문제 등 복잡도가 증가.
  - 예: 일부 파일 공유/분산 앱.

- **Hybrid (혼합형)**

  - 로그인/검색은 서버, 데이터 전송은 P2P 등 혼합 설계가 흔하다.

### 1.2 Process Communicating (프로세스 통신)

- 네트워크 앱은 여러 **Process (프로세스)** 가 서로 메시지를 주고받는다.
- 동일 호스트 내부는 IPC로 충분하지만, 다른 호스트 간 통신은 네트워크가 필요.

### 1.3 Sockets (소켓)

- **Socket (소켓)**: 애플리케이션이 네트워크로 데이터를 주고받는 “문(door)”.
- 앱은 소켓에 데이터를 **send/receive** 하고, 아래 계층(전송/네트워크)이 실제 전달을 담당.

### 1.4 Addressing (주소 지정)

- 프로세스를 식별하려면 보통:

  - **IP Address (IP 주소)**: 호스트 식별
  - **Port Number (포트 번호)**: 호스트 내 프로세스(서비스) 식별

---

## 2. Transport Services the Application Needs (전송 계층 서비스 요구사항)

### 2.1 데이터 전달 관점

- **Reliable Data Transfer (신뢰적 전송)**

  - 데이터 손실이 허용되지 않는 앱(파일 전송, 이메일, 웹 페이지의 기본 전송 등)은 신뢰성이 중요.

- **Throughput (처리율/대역 요구)**

  - 일정 이상의 처리율이 필요(스트리밍 고화질, 대용량 전송 등)할 수 있음.
  - 반대로 “최소 처리율 보장”이 없더라도 적응형 비트레이트처럼 앱이 적응할 수도 있다.

- **Timing / Delay (지연 요구)**

  - 실시간성(VoIP, 온라인 게임)은 낮은 지연이 중요.

- **Security (보안)**

  - **Confidentiality (기밀성)**, **Integrity (무결성)**, **Authentication (인증)** 등이 필요할 수 있음.
  - 전송 계층 위의 **TLS** 같은 방식으로 제공되는 경우가 많다.

### 2.2 Internet Transport Protocols (인터넷 전송 프로토콜)

- **TCP (Transmission Control Protocol)**

  - 연결지향, 신뢰적 전송, 혼잡 제어.
  - 바이트 스트림 기반(메시지 경계는 앱이 관리).

- **UDP (User Datagram Protocol)**

  - 비연결, 신뢰성/순서 보장 없음, 오버헤드가 작음.
  - 메시지(데이터그램) 단위.

---

## 3. Web and HTTP (웹과 HTTP)

### 3.1 Web Basics (웹의 기본)

- **Web Page (웹 페이지)** 는 여러 **Object (오브젝트)** 로 구성(HTML, 이미지, JS, CSS 등).
- 각 오브젝트는 **URL** 로 식별된다.

### 3.2 HTTP Overview (HTTP 개요)

- **HTTP (HyperText Transfer Protocol)**: 웹의 대표 **Application Protocol**.
- **Client (브라우저)** 가 **HTTP Request**, **Server (웹 서버)** 가 **HTTP Response**.
- **Stateless (무상태)**: 서버는 기본적으로 클라이언트의 “이전 요청 상태”를 저장하지 않는다.

### 3.3 Persistent vs Non-persistent Connections (지속/비지속 연결)

- **Non-persistent HTTP (비지속 HTTP)**

  - 오브젝트마다 TCP 연결을 새로 맺고 끊는 방식.
  - 지연/오버헤드 증가.

- **Persistent HTTP (지속 HTTP)**

  - 하나의 TCP 연결을 유지하며 여러 오브젝트를 연속 요청.
  - 성능 개선(연결 설정 비용 감소).

### 3.4 HTTP Message Format (HTTP 메시지 형식)

- **Request Message**: 요청 라인(method, URL path, version) + 헤더들 + (옵션) 바디

  - 대표 메서드: **GET, POST, HEAD, PUT, DELETE** 등

- **Response Message**: 상태 라인(status code) + 헤더들 + 바디

  - 대표 상태코드: **200 OK, 301 Moved Permanently, 400 Bad Request, 404 Not Found, 505 HTTP Version Not Supported** 등

### 3.5 Cookies (쿠키)와 상태 유지

- HTTP는 무상태지만, 로그인/세션 같은 상태를 위해 **Cookie (쿠키)** 를 사용.
- 쿠키로 사용자 식별자를 저장하면 서버는 그 식별자로 사용자 상태를 간접적으로 관리 가능.

### 3.6 Web Caching (웹 캐싱)

- **Web Cache / Proxy (웹 캐시/프록시)**: 원 서버 대신 자주 요청되는 오브젝트를 저장해 제공.
- 장점: 응답 시간 감소, 백본/서버 부하 감소.
- **Conditional GET (조건부 GET)** 같은 기법으로 최신성 검증을 한다.

---

## 4. Electronic Mail (전자 메일)

### 4.1 Email System Components (이메일 시스템 구성)

- **User Agent (사용자 에이전트)**: 사용자가 메일을 읽고 쓰는 클라이언트.
- **Mail Server (메일 서버)**: 메일박스 관리/전달.
- **SMTP (Simple Mail Transfer Protocol)**: 메일 서버 간(또는 클라이언트→서버) 메일 전송.

### 4.2 SMTP 특징

- 기본적으로 **push (푸시)** 방식(보내는 쪽이 밀어 넣는다).
- 메시지 본문은 전통적으로 ASCII 기반이며, 첨부는 보통 **MIME** 로 처리.

### 4.3 Mail Access Protocols (메일 접근 프로토콜)

- 수신자가 서버에서 메일을 가져오거나 동기화:

  - **POP3**: 단순 다운로드 중심
  - **IMAP**: 서버에 메일을 두고 폴더/동기화 지원
  - (현실에선 HTTP 기반 웹메일도 흔함)

---

## 5. DNS (Domain Name System)

> DNS는 ‘인터넷의 전화번호부’ 역할: **Host Name (호스트 이름)** 을 **IP Address** 로 변환한다.

### 5.1 DNS 제공 기능

- **Name-to-IP Translation (이름→IP 변환)**
- **Host Aliasing (호스트 별칭)**: canonical name ↔ alias name
- **Mail Server Aliasing (메일 서버 별칭)**
- **Load Distribution (부하 분산)**: 여러 IP를 반환해 트래픽 분산

### 5.2 DNS 구조: 분산/계층 데이터베이스

- 단일 중앙 DB가 아니라, 확장성과 관리성을 위해 **Hierarchical (계층적)** + **Distributed (분산)**.
- 대표 계층:

  - **Root DNS Servers (루트 DNS)**
  - **TLD DNS Servers (최상위 도메인 DNS)**
  - **Authoritative DNS Servers (권한 DNS)**

- 조직/ISP는 보통 **Local DNS Resolver (로컬 DNS 리졸버)** 를 통해 질의한다.

### 5.3 DNS Query (DNS 질의)

- **Recursive Query (재귀 질의)**: 리졸버가 결과를 끝까지 받아 사용자에게 전달.
- **Iterative Query (반복 질의)**: 다음에 물어볼 서버 정보를 받아가며 순차 탐색.

### 5.4 DNS Caching (DNS 캐싱)

- 질의 결과를 일정 시간(**TTL**) 저장해 지연과 트래픽을 줄인다.
- 캐시로 인해 변경 전파가 즉시 반영되지 않을 수 있다.

### 5.5 DNS Records (DNS 레코드)

- 일반적으로 (Name, Value, Type, TTL) 형태.
- 대표 타입:

  - **A**: hostname → IPv4
  - **AAAA**: hostname → IPv6
  - **NS**: 도메인의 권한 DNS 서버
  - **CNAME**: 별칭 → 정식 이름
  - **MX**: 메일 서버

---

## 6. Peer-to-Peer Applications (P2P 애플리케이션)

### 6.1 P2P의 특징

- 서버 의존도를 줄이고 피어들이 자원을 제공.
- 장점: 확장성, 비용 분산 가능
- 단점: 피어 가용성 변동, NAT/방화벽 이슈, 보안/신뢰 문제

### 6.2 File Distribution 관점

- 전통적 클라이언트–서버는 서버 업로드가 병목이 되기 쉽다.
- P2P는 피어가 늘면 전체 업로드 자원도 늘어 분배 시간이 줄어들 수 있다(이상적인 경우).

---

## 7. Video Streaming and CDNs (비디오 스트리밍과 CDN)

### 7.1 스트리밍의 기본 이슈

- 네트워크 처리율 변동, 지연, 손실로 인해 끊김이 발생할 수 있음.
- 해결 방향: 버퍼링, 적응형 비트레이트 등.

### 7.2 CDN (Content Delivery Network)

- 전 세계에 분산된 서버에 콘텐츠를 복제해 사용자와 가까운 곳에서 제공.
- 목표: 지연 감소, 트래픽 분산, 원 서버 부하 감소.
- DNS를 이용해 “가까운/적절한” CDN 노드로 유도하는 방식이 흔하다.

---

## 8. Socket Programming with UDP and TCP (UDP/TCP 소켓 프로그래밍 개요)

### 8.1 UDP 소켓

- 비연결: 송신은 바로 send, 수신은 recv.
- 신뢰성/순서/재전송은 앱이 필요 시 구현.

### 8.2 TCP 소켓

- 연결지향: **3-way handshake** 로 연결 설정 후 데이터 송수신.
- 서버는 보통:

  - **Welcome Socket** 으로 연결 요청을 받고,
  - 연결마다 별도 소켓을 만들어 다중 클라이언트를 처리.

---

## 9. Summary (요약)

- 애플리케이션 계층은 **앱 구조(클라-서버/P2P)** 와 **프로토콜(HTTP/DNS/Email)** 로 인터넷 서비스를 만든다.
- 앱은 **소켓** 을 통해 전송 계층 서비스를 사용하며, 요구사항(신뢰성/지연/처리율/보안)에 따라 **TCP/UDP** 를 선택한다.
- 웹은 **HTTP(무상태)** 를 기반으로 하며, **지속 연결, 쿠키, 캐싱** 으로 성능/상태 문제를 해결한다.
- DNS는 분산 계층 구조로 **이름→IP 변환**, 캐싱(TTL), 레코드 타입(A/AAAA/NS/CNAME/MX) 등을 제공한다.
- 스트리밍은 처리율 변동을 다루기 위해 버퍼링/적응을 사용하고, **CDN** 으로 지연과 부하를 줄인다.

# Ch 3. Transport Layer (트랜스포트 계층)

> 큰 흐름: **Transport Layer (트랜스포트 계층)** 은 서로 다른 호스트에서 실행되는 애플리케이션 **process-to-process** 통신을 제공한다. 핵심은 (1) **Multiplexing/Demultiplexing (다중화/역다중화)** 로 “어느 프로세스에게 줄 데이터인가”를 해결하고, (2) **Reliable Data Transfer (신뢰적 전송)** 을 end-to-end로 구현하며, (3) **TCP** 가 **Flow Control (흐름제어)** 과 **Congestion Control (혼잡제어)** 로 성능/안정성을 확보하는 것이다.

---

## 1. Transport-Layer Services and Overview (전송 계층 서비스 개요)

### 1.1 전송 계층이 제공하는 것

- **Process-to-Process Delivery (프로세스 간 전달)**

  - 네트워크 계층(IP)이 “호스트까지” 보내면,
  - 전송 계층이 “호스트 내부의 특정 프로세스(소켓)까지” 전달한다.

- **Segmentation / Reassembly (분할/재조립)**

  - 애플리케이션 메시지를 전송 단위인 **Segment (세그먼트)** 로 쪼개고, 수신 측에서 재조립.

- (TCP의 경우) **Reliable, In-order Delivery (신뢰적/순서 보장 전달)**
- (TCP의 경우) **Flow Control / Congestion Control**

### 1.2 Transport vs Network (전송 vs 네트워크)

- **Network Layer (IP)**: best-effort로 패킷을 목적지 호스트까지 운반(손실/재정렬 가능).
- **Transport Layer**: end system에서만 동작하며, 앱이 원하는 “서비스 품질”을 프로토콜(TCP/UDP)로 제공.

### 1.3 Transport Protocols in the Internet

- **UDP**: 비연결, 단순, 최소 기능(체크섬 + 포트 기반 전달)
- **TCP**: 연결지향, 신뢰적 바이트 스트림, 흐름/혼잡 제어

---

## 2. Multiplexing and Demultiplexing (다중화/역다중화)

### 2.1 왜 필요한가?

- 한 호스트에서 브라우저/게임/메신저 등 여러 앱이 동시에 통신.
- 전송 계층은:

  - 송신: 여러 소켓에서 나온 데이터를 **하나의 전송 계층**이 받아 세그먼트로 만들고(**Multiplexing**)
  - 수신: 도착한 세그먼트를 **올바른 소켓**으로 보내야 한다(**Demultiplexing**)

### 2.2 포트와 소켓 식별

- **Port Number (포트 번호)**: 호스트 내부 프로세스(서비스) 식별.
- **UDP Demux**

  - 주로 **Destination Port** 로 소켓을 결정(단일 소켓이 여러 송신자를 받을 수 있음).

- **TCP Demux**

  - 연결마다 소켓이 분리되며 일반적으로 **4-tuple** 로 구분:
  - (Source IP, Source Port, Destination IP, Destination Port)

### 2.3 Well-known Ports (대표 포트 예)

- HTTP 80, HTTPS 443, DNS 53, SMTP 25 등(개념 이해 목적).

---

## 3. Connectionless Transport: UDP (비연결 전송: UDP)

### 3.1 UDP 서비스/특징

- **Connectionless**: 핸드셰이크 없이 즉시 전송.
- **No reliability / No ordering / No congestion control**
- **Low overhead**: 헤더가 작고(단순), 구현/상태 관리가 거의 없음.

### 3.2 UDP가 유리한 상황

- **지연이 중요**하거나(핸드셰이크/재전송 부담 회피)
- **애플리케이션이 자체적으로 신뢰성/전송률을 제어**하는 경우
- **단순 질의/응답** 패턴(DNS 같은 작은 요청/응답)에서 오버헤드가 부담일 때

### 3.3 UDP 체크섬(Checksum)

- 목적: 전송 중 비트 오류 검출.
- 인터넷에서는 링크 계층이 오류를 잡더라도 “종단 간” 안전을 위해 전송 계층에서도 오류 검출을 둔다.

### 3.4 UDP 세그먼트 헤더

- **Source Port / Destination Port**
- **Length**
- **Checksum**

---

## 4. Principles of Reliable Data Transfer (신뢰적 데이터 전송 원리)

> 목표: 손실/오류/재정렬이 가능한 네트워크 위에서 “마치 완벽한 채널처럼” 동작하는 서비스를 end-to-end로 만든다.

### 4.1 핵심 아이디어(빌딩 블록)

- **Error detection**: 체크섬
- **Receiver feedback**: ACK/NAK(개념), TCP는 ACK 중심
- **Retransmission**: 손실 추정 시 재전송
- **Sequence numbers**: 중복/순서 뒤바뀜 처리
- **Timers**: ACK가 오지 않으면 타임아웃 후 재전송

### 4.2 Stop-and-Wait (정지-대기) 개념

- 한 번에 하나 보내고 ACK 기다림 → 단순하지만 링크가 길거나 대역이 클수록 비효율.
- 효율 직관:

  - 왕복시간(RTT)이 크면 “기다리는 시간”이 커져 처리율이 떨어짐.

### 4.3 Pipelining (파이프라이닝)

- 여러 패킷을 연속으로 보내 “대기 시간을 숨김”.
- 파이프라이닝을 위해 필요한 것:

  - **송신 윈도우**(ACK 전까지 보낼 수 있는 범위)
  - **버퍼링**(미확인 데이터 저장)

### 4.4 Go-Back-N (GBN)

- 송신자는 윈도우 내 여러 패킷을 보냄.
- 수신자는 **in-order**만 수용하고, 누락 발생 시 그 이후는 버림.
- ACK는 보통 **누적 ACK(cumulative ACK)**.
- 손실 시: “누락된 패킷부터 이후 모두” 재전송 → 단순하지만 낭비 가능.

### 4.5 Selective Repeat (SR)

- 수신자는 out-of-order도 버퍼링.
- 송신자는 **개별 패킷 단위**로 ACK/타이머 관리.
- 손실 시: 누락된 것만 재전송 → 효율적이지만 상태/복잡도 증가.

---

## 5. Connection-Oriented Transport: TCP (연결지향 전송: TCP)

### 5.1 TCP가 제공하는 서비스

- **Reliable, in-order byte stream (신뢰적/순서 보장 바이트 스트림)**
- **Full-duplex (전이중)**: 양방향 동시에 데이터 가능
- **Point-to-point (1:1)**: 멀티캐스트 아님
- **Flow control** + **Congestion control**

### 5.2 TCP는 “바이트 스트림”이다

- UDP는 메시지 단위(데이터그램) 경계가 유지되는 반면,
- TCP는 애플리케이션이 쓴 바이트 흐름을 연속적으로 전달.
- 메시지 경계는 애플리케이션 프로토콜(예: HTTP)에서 처리.

---

## 6. TCP Segment Structure (TCP 세그먼트 구조)

### 6.1 핵심 필드

- **Source Port / Destination Port**
- **Sequence Number (Seq)**

  - “세그먼트에 담긴 데이터의 첫 바이트 번호”

- **Acknowledgment Number (Ack)**

  - “다음에 기대하는 바이트 번호”(누적 ACK)

- **Header Length**
- **Flags**

  - **SYN**(연결 설정), **FIN**(연결 종료), **ACK**, **RST**, **PSH**, **URG**

- **Receive Window (rwnd)**
- **Checksum**
- **Options**

  - 예: MSS, 윈도우 확장, SACK 옵션 등(개념적으로)

### 6.2 MSS와 세그먼트 크기

- **MSS (Maximum Segment Size)**: TCP payload 최대 크기(대략 MTU에서 IP/TCP 헤더를 뺀 값).

---

## 7. TCP Reliable Data Transfer (TCP 신뢰성 메커니즘)

### 7.1 누적 ACK (Cumulative ACK)

- 수신자는 “연속으로 받은 마지막 바이트 이후”를 ACK.
- 장점: ACK 관리 단순.
- 단점: 중간 손실이 있어도 이후 도착한 out-of-order 데이터는 누적 ACK에 반영되지 않음.

### 7.2 재전송 트리거

- **Timeout (타임아웃)**: ACK가 일정 시간 안 오면 손실로 간주.
- **Duplicate ACKs (중복 ACK)**

  - 같은 ACK 번호가 반복되면 “중간에 빠진 세그먼트가 있다” 신호.
  - 보통 **3 duplicate ACK** → **Fast Retransmit (빠른 재전송)**

### 7.3 RTT 추정과 RTO(재전송 타이머)

- TCP는 네트워크 상황이 변하므로 타임아웃을 고정하면 위험.
- 아이디어:

  - **SampleRTT** 측정 → **EstimatedRTT** 를 지수평활로 갱신
  - 변동성까지 고려한 **DevRTT** 를 함께 추정
  - **RTO = EstimatedRTT + 4 \* DevRTT** 형태로 설정(대표적인 형태)

- 타임아웃 재전송 후에는 타이머를 키우는 **exponential backoff** 를 적용하는 것이 일반적.

### 7.4 Sender/Receiver Buffering

- 송신자는 미확인 데이터(재전송 대비)를 버퍼에 저장.
- 수신자는 순서대로 앱에 전달하기 위해 버퍼를 사용(특히 out-of-order 수용 시).

---

## 8. TCP Flow Control (TCP 흐름 제어)

### 8.1 목적

- 송신자가 너무 빨리 보내 수신자 버퍼가 넘치는 것을 방지.

### 8.2 Receive Window (rwnd)

- 수신자는 현재 버퍼 여유를 **rwnd** 로 광고(advertise).
- 송신자는 미확인 데이터 양을 대략 `<= rwnd` 로 제한.

### 8.3 (중요) Flow vs Congestion

- **Flow control**: 수신자 보호(수신 버퍼/처리 능력)
- **Congestion control**: 네트워크 보호(라우터 큐/링크 혼잡)
- TCP 송신 제한은 보통 `min(rwnd, cwnd)` 관점으로 이해.

---

## 9. TCP Connection Management (TCP 연결 관리)

### 9.1 3-way Handshake

1. Client → Server: **SYN** (초기 Seq 제안)
2. Server → Client: **SYN+ACK**
3. Client → Server: **ACK**

- 목적: 양쪽 초기 시퀀스 번호 동기화 + 연결 상태 확립.

### 9.2 연결 종료

- 일반적으로 **FIN** 기반으로 각 방향을 독립적으로 종료(half-close 가능).
- 종료 과정은 상태 전이(TIME_WAIT 등)를 동반.

---

## 10. Principles of Congestion Control (혼잡 제어 원리)

### 10.1 혼잡이 생기면?

- 라우터 큐가 길어짐 → **Queueing delay 증가**
- 버퍼가 가득 차면 **패킷 손실(drop)**
- 재전송이 늘면 더 혼잡해지는 악순환 가능.

### 10.2 혼잡 제어 접근

- **End-to-end**: 네트워크가 명시적 신호를 주지 않아도, 종단에서 손실/지연을 보고 추정(TCP 기본 철학)
- **Network-assisted**: 라우터가 혼잡을 표시(ECN 같은 개념)

### 10.3 성능 목표

- 높은 처리율, 낮은 지연, 공정한 공유.

---

## 11. TCP Congestion Control (TCP 혼잡 제어)

> 큰 줄기: **AIMD** 기반으로 cwnd를 조절하며, 손실(또는 혼잡 신호) 시 크게 줄이고, 혼잡이 없으면 늘린다.

### 11.1 Congestion Window (cwnd)

- 송신자가 네트워크 혼잡을 고려해 설정하는 “네트워크 관점의 송신 윈도우”.
- 실전 송신 가능량(미확인 데이터)은 대략 `min(cwnd, rwnd)`.

### 11.2 Slow Start (슬로 스타트)

- 연결 시작 시 cwnd를 작게 두고 **지수적 증가**(RTT마다 2배 수준)로 가용 대역을 탐색.
- **ssthresh** 를 기준으로 다음 단계 전환.

### 11.3 Congestion Avoidance (혼잡 회피)

- cwnd를 **선형 증가**(RTT당 대략 1 MSS)로 안정적으로 확장.

### 11.4 Loss Detection에 따른 반응

- **Timeout loss** (더 심각한 혼잡으로 간주)

  - cwnd를 크게 줄이고(초기화 수준), slow start로 돌아가는 흐름이 흔함.

- **Triple duplicate ACK loss** (상대적으로 덜 심각)

  - **Fast retransmit** + **빠른 회복(빠른 재전송 후 cwnd를 덜 극단적으로 감소)**
  - (구체 구현은 TCP Reno 계열에서 강조)

### 11.5 AIMD 직관

- 혼잡 없으면 천천히(+1) 늘려 안정적으로 공유
- 혼잡 시 절반(×1/2) 줄여 네트워크를 빠르게 진정

---

## 12. TCP Throughput and Fairness (처리율과 공정성)

### 12.1 TCP 처리율 직관

- 처리율은 대략 **cwnd / RTT** 규모로 생각할 수 있다.
- 손실 이벤트가 자주 나면 cwnd가 자주 줄어 평균 처리율이 낮아짐.

### 12.2 공정성(Fairness)

- 동일 병목을 공유하는 여러 TCP 연결은(이상적 가정에서) 대역을 비슷하게 나누는 경향.
- 하지만:

  - RTT가 큰 연결은 불리할 수 있고,
  - 한 애플리케이션이 여러 TCP 연결을 만들면 더 많은 몫을 가져갈 수 있다.

---

## 13. UDP vs TCP 선택 기준 (정리)

- **UDP**

  - 지연/단순성 우선, 앱이 제어, 오버헤드 최소
  - 신뢰성/혼잡제어는 앱 책임

- **TCP**

  - 신뢰성, 순서 보장, 흐름/혼잡 제어가 필요할 때
  - 연결 관리/오버헤드가 있지만 일반적인 데이터 전송의 기본 선택지

---

## 14. Summary (요약)

- 전송 계층은 **포트 기반 다중화/역다중화**로 프로세스 간 전달을 제공한다.
- **UDP** 는 비연결·저오버헤드이며 기본 전달/오류검출만 제공한다.
- **신뢰적 전송**은 시퀀스 번호, ACK, 재전송, 타이머, 파이프라이닝(GBN/SR) 같은 메커니즘으로 구현된다.
- **TCP** 는 바이트 스트림 형태로 신뢰성을 제공하며, **RTT 추정/RTO**, **Fast Retransmit** 등으로 성능을 개선한다.
- **Flow control(rwnd)** 은 수신자 보호, **Congestion control(cwnd, AIMD)** 은 네트워크 보호이며 실제 송신량은 `min(rwnd, cwnd)` 관점으로 이해한다.
- TCP 혼잡 제어는 **Slow Start → Congestion Avoidance → (Fast Retransmit/Recovery)** 흐름으로 가용 대역을 탐색하고 혼잡 시 빠르게 감소한다.

---

# Ch 4. The Network Layer: Data Plane (네트워크 계층: 데이터 플레인)

> 큰 흐름: **Network Layer (네트워크 계층)** 은 패킷을 출발지 호스트에서 목적지 호스트로 전달한다. 4장은 그중에서도 라우터 내부에서 “패킷 한 개를 어떻게 처리해 다음 홉으로 넘기는가”에 집중하는 **Data Plane (데이터 플레인)** 을 다룬다. 핵심은 **Forwarding (포워딩)**, **Router Architecture (라우터 구조)**, **IP Datagram (IP 데이터그램) 포맷과 IPv4/IPv6**, **Fragmentation (단편화)**, **NAT**, 그리고 **Generalized Forwarding/SDN** 관점이다.

---

## 1. Overview of Network Layer (네트워크 계층 개요)

### 1.1 Data Plane vs Control Plane

- **Data Plane (데이터 플레인)**

  - 라우터가 도착한 패킷을 보고 **입력 포트 → 출력 포트**로 넘기는 로컬 동작.
  - 핵심 동작: **Forwarding**.

- **Control Plane (컨트롤 플레인)**

  - 패킷이 어떤 경로로 가야 하는지 **Routing (라우팅)** 을 결정.
  - 5장에서 라우팅 알고리즘/프로토콜을 다룸.

### 1.2 Forwarding vs Routing

- **Forwarding (포워딩)**: 라우터 한 대 내부에서 “다음 홉으로” 내보내는 동작(짧은 시간 스케일).
- **Routing (라우팅)**: 네트워크 전체 관점에서 경로를 선택(긴 시간 스케일).

---

## 2. The Router: Architecture and Functions (라우터: 구조와 기능)

### 2.1 라우터의 기본 구성

- **Input Ports (입력 포트)**

  - 물리 계층/링크 계층 처리
  - **Lookup/Forwarding Table 검색**
  - 입력 큐(혼잡 시 대기)

- **Switching Fabric (스위칭 패브릭)**

  - 입력 포트에서 출력 포트로 패킷을 옮기는 내부 스위치

- **Output Ports (출력 포트)**

  - 출력 큐(대기)
  - 링크 계층 프레이밍 후 전송

- **Routing Processor (라우팅 프로세서)**

  - 컨트롤 플레인 기능 수행(라우팅 프로토콜, 테이블 관리)

### 2.2 Forwarding Table / Longest Prefix Match

- 라우터는 목적지 IP 주소를 보고 **Forwarding Table** 을 조회해 출력 포트를 결정.
- IP는 계층적 주소(프리픽스 기반)이므로:

  - 여러 항목이 매칭될 수 있고, 가장 구체적인 경로가 우선 → **Longest Prefix Match (최장 프리픽스 매칭)**.

### 2.3 Switching Fabric 구현 방식

- **Memory-based (메모리 기반)**

  - CPU/메모리를 통해 복사하며 전달(초기 라우터 방식). 메모리 대역이 병목.

- **Bus-based (버스 기반)**

  - 공유 버스를 통해 전달. 버스 대역이 병목.

- **Interconnection Network / Crossbar (상호연결망/크로스바)**

  - 병렬 전송에 유리, 고성능 라우터에서 흔함.

### 2.4 Queueing inside Routers (라우터 내부 큐잉)

- 입력/출력 링크 속도 불일치나 트래픽 버스트로 큐가 생김.
- **Input Queueing (입력 큐잉)**

  - 여러 입력이 같은 출력으로 가려면 대기 발생.
  - 대표 문제: **HOL Blocking (Head-of-Line 블로킹)**

    - 큐 맨 앞 패킷이 막히면 뒤 패킷도 못 지나감.

- **Output Queueing (출력 큐잉)**

  - 출력 링크가 바쁠 때 출력 버퍼에서 대기.

- **Buffer Overflow → Packet Loss (버퍼 초과 → 손실)**

### 2.5 Packet Scheduling (패킷 스케줄링)

- 출력 링크로 어떤 순서로 내보낼지 결정.
- 대표 정책:

  - **FIFO**: 단순, 공정성/지연 제어 한계
  - **Priority Scheduling (우선순위)**: 우선순위 높은 트래픽 지연 감소(낮은 쪽 starvation 위험)
  - **Round Robin / Weighted Round Robin (RR/WRR)**: 흐름/클래스 간 공정성 개선

---

## 3. The Internet Protocol (IP): IPv4 (인터넷 프로토콜: IPv4)

### 3.1 IP의 서비스 모델

- **Best-effort delivery (최선형 서비스)**

  - 지연 보장 없음
  - 손실/재정렬 가능
  - 대역 보장 없음

- 따라서 신뢰성/순서 보장은 전송 계층(TCP)이나 애플리케이션이 담당.

### 3.2 IPv4 Datagram Format (IPv4 데이터그램 포맷)

- 핵심 필드(의미 위주):

  - **Version**: IPv4
  - **Header Length (IHL)**: 헤더 길이
  - **Type of Service (ToS) / DSCP**: QoS 분류용
  - **Total Length**: 전체 길이
  - **Identification / Flags / Fragment Offset**: 단편화 관련
  - **TTL (Time To Live)**: 홉마다 감소, 0이면 폐기(루프 방지)
  - **Protocol**: 상위 전송 프로토콜(TCP=6, UDP=17 등)
  - **Header Checksum**: 헤더 오류 검출(홉마다 재계산)
  - **Source IP / Destination IP**
  - **Options (옵션)**: 가변(현대 인터넷에서는 제한적으로 사용)

### 3.3 IPv4 Addressing (IPv4 주소)

- **32-bit 주소**.
- 계층적 구조(네트워크 프리픽스 + 호스트 부분).
- 표기: 점-10진 표기(예: 128.119.40.186).

---

## 4. Fragmentation (단편화)

### 4.1 MTU와 단편화가 생기는 이유

- 링크마다 한 번에 실을 수 있는 최대 프레임 크기: **MTU (Maximum Transmission Unit)**.
- IP 데이터그램이 MTU보다 크면 링크 계층에 그대로 못 실음.

### 4.2 IPv4 단편화 방식

- 송신 데이터그램을 여러 **Fragment (조각)** 으로 쪼개 전송.
- 수신 측에서 재조립.
- 관련 필드:

  - **Identification**: 원본 데이터그램 식별
  - **Fragment Offset**: 원본에서의 위치
  - **MF (More Fragments) 플래그**: 뒤에 조각이 더 있는지

- 단편화는 오버헤드/손실 확률 증가를 유발(조각 중 하나만 잃어도 전체 재조립 실패).

---

## 5. IPv4 to IPv6 (IPv4에서 IPv6로)

### 5.1 IPv6 동기

- 주소 고갈(IPv4 32-bit 한계)
- 헤더 단순화/확장성 개선

### 5.2 IPv6 Datagram (IPv6 데이터그램) 특징

- **128-bit 주소**
- 기본 헤더가 더 단순(일부 필드 제거/변경):

  - IPv4의 헤더 체크섬 제거(성능/중복 기능 고려)
  - 단편화는 기본적으로 라우터가 하지 않음(송신단에서 처리, 확장 헤더로)

- **Flow Label** 등 QoS/플로우 식별 지원.

### 5.3 Transition Mechanisms (전환 메커니즘)

- **Tunneling (터널링)**

  - IPv6 패킷을 IPv4 페이로드로 캡슐화해 IPv4 네트워크를 통과.

- (실제 전환은 혼합 환경이 길게 지속될 수 있음)

---

## 6. Addressing in Practice: Subnets, DHCP, CIDR (주소/서브넷/할당)

### 6.1 Subnet (서브넷)

- 같은 서브넷 내 호스트는 라우터를 거치지 않고 서로 직접 도달 가능한 범위.
- 서브넷은 보통 **프리픽스/서브넷 마스크** 로 표현.

### 6.2 CIDR (Classless InterDomain Routing)

- 클래스 A/B/C 고정 경계를 쓰지 않고 프리픽스 길이로 표현.
- 표기: `a.b.c.d/x` (x = 프리픽스 길이).
- 장점: 주소 낭비 감소, 라우팅 테이블 집계(aggregation) 용이.

### 6.3 DHCP (Dynamic Host Configuration Protocol)

- 호스트가 네트워크에 접속하면 자동으로:

  - IP 주소, 서브넷 마스크, 기본 게이트웨이, DNS 서버 등을 받음.

- 일반적 절차(DORA):

  - **Discover → Offer → Request → ACK**

---

## 7. NAT (Network Address Translation)

### 7.1 NAT의 목적/배경

- 사설망 내부 호스트가 **Private IP** 를 쓰고,
- 외부 인터넷에는 **하나(또는 소수)의 Public IP** 로 나가게 하는 기술.
- 주소 부족 완화 + 내부 주소/구조 은닉 효과.

### 7.2 NAT 동작(포트 기반 변환)

- 내부 호스트의 (src IP, src port)을

  - NAT 라우터의 (public IP, new port)로 매핑.

- NAT 장비는 **NAT translation table** 을 유지.

### 7.3 NAT의 논쟁점

- 장점: IPv4 주소 절약, 관리 편의.
- 단점:

  - end-to-end 원칙 약화
  - 서버 운영/피어 투 피어에 불리(외부에서 내부로 연결 어려움)
  - 애플리케이션/프로토콜이 NAT 친화적으로 설계되어야 하는 경우 발생.

---

## 8. Generalized Forwarding and SDN (일반화된 포워딩과 SDN)

### 8.1 전통적 포워딩 vs 일반화된 포워딩

- 전통 라우터: 주로 **Destination IP 프리픽스 매칭** 기반.
- **Generalized Forwarding**: 다양한 헤더 필드(예: 5-tuple, VLAN, MPLS 라벨 등) 매칭 후 동작 수행.

### 8.2 Match + Action (매치-액션) 관점

- 규칙: “어떤 필드 패턴과 매치되면 → 어떤 액션을 한다”
- 액션 예:

  - 특정 포트로 포워딩
  - 드롭
  - 헤더 수정
  - 컨트롤러로 전달

### 8.3 SDN (Software-Defined Networking) 연결고리

- 데이터 플레인은 단순 포워딩(스위치/라우터),
- 컨트롤 플레인은 논리적으로 중앙화된 컨트롤러가 정책/경로를 결정(개념).

---

## 9. Summary (요약)

- 4장은 네트워크 계층 중 **Data Plane**: 라우터가 패킷을 **forwarding** 하는 내부 동작을 다룬다.
- 라우터는 **입력 포트–스위칭 패브릭–출력 포트** 로 구성되고, **Longest Prefix Match** 로 포워딩 결정을 한다.
- 큐잉은 입력/출력에서 발생하며, **HOL 블로킹**, **버퍼 오버플로우 손실**, **스케줄링 정책(FIFO/우선순위/RR/WRR)** 이 성능을 좌우한다.
- **IPv4** 는 best-effort 데이터그램 서비스이며, 헤더에는 TTL/프로토콜/단편화 필드 등이 있다.
- **Fragmentation** 은 MTU 차이로 발생하며 오버헤드를 유발한다.
- **IPv6** 는 128-bit 주소와 단순화된 헤더로 확장성을 높이며, 전환은 **터널링** 등으로 이뤄진다.
- 실전 주소 할당은 **서브넷/CIDR/DHCP** 로 운영되며, **NAT** 는 사설망의 공인 IP 공유를 가능하게 하지만 end-to-end를 약화시킨다.
- 최근 관점에서는 **Generalized Forwarding(매치-액션)** 과 **SDN** 이 데이터 플레인/컨트롤 플레인을 분리해 유연성을 높인다.
