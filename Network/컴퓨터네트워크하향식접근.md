> 컴퓨터 네트워크 하향식 접근 책을 읽고 정리한 내용입니다.

# 목차

- [목차](#목차)
- [Ch 1. Computer Networks and the Internet (컴퓨터 네트워크와 인터넷)](#ch-1-computer-networks-and-the-internet-컴퓨터-네트워크와-인터넷)
  - [1. What Is the Internet? (인터넷이란?)](#1-what-is-the-internet-인터넷이란)
    - [1.1 구성요소 관점 (nuts-and-bolts view)](#11-구성요소-관점-nuts-and-bolts-view)
    - [1.2 서비스 관점 (service view)](#12-서비스-관점-service-view)
    - [1.3 프로토콜이란? (What is a protocol?)](#13-프로토콜이란-what-is-a-protocol)
  - [2. Network Edge (네트워크의 가장자리)](#2-network-edge-네트워크의-가장자리)
    - [2.1 Access Network (접속 네트워크)](#21-access-network-접속-네트워크)
    - [2.2 Physical Media (물리 매체)](#22-physical-media-물리-매체)
  - [3. Network Core (네트워크의 중심)](#3-network-core-네트워크의-중심)
    - [3.1 Packet Switching (패킷 교환)](#31-packet-switching-패킷-교환)
    - [3.2 Circuit Switching (회선 교환)과 비교](#32-circuit-switching-회선-교환과-비교)
    - [3.3 Delay, Loss, Throughput (지연/손실/처리율)](#33-delay-loss-throughput-지연손실처리율)
  - [4. Protocol Layers and Service Models (프로토콜 계층과 서비스 모델)](#4-protocol-layers-and-service-models-프로토콜-계층과-서비스-모델)
    - [4.1 Layering (계층화)의 목적](#41-layering-계층화의-목적)
    - [4.2 Internet Protocol Stack (인터넷 5계층 스택)](#42-internet-protocol-stack-인터넷-5계층-스택)
    - [4.3 Encapsulation (캡슐화)](#43-encapsulation-캡슐화)
    - [4.4 OSI Model (OSI 7계층)과의 관계](#44-osi-model-osi-7계층과의-관계)
  - [5. Networks Under Attack (공격받는 네트워크)](#5-networks-under-attack-공격받는-네트워크)
    - [5.1 대표 공격/위협](#51-대표-공격위협)
    - [5.2 방어의 큰 방향](#52-방어의-큰-방향)
  - [6. Summary (요약)](#6-summary-요약)
- [Ch 2. Application Layer (애플리케이션 계층)](#ch-2-application-layer-애플리케이션-계층)
  - [1. Principles of Network Applications (네트워크 애플리케이션의 원리)](#1-principles-of-network-applications-네트워크-애플리케이션의-원리)
    - [1.1 Application Architecture (애플리케이션 구조)](#11-application-architecture-애플리케이션-구조)
    - [1.2 Process Communicating (프로세스 통신)](#12-process-communicating-프로세스-통신)
    - [1.3 Sockets (소켓)](#13-sockets-소켓)
    - [1.4 Addressing (주소 지정)](#14-addressing-주소-지정)
  - [2. Transport Services the Application Needs (전송 계층 서비스 요구사항)](#2-transport-services-the-application-needs-전송-계층-서비스-요구사항)
    - [2.1 데이터 전달 관점](#21-데이터-전달-관점)
    - [2.2 Internet Transport Protocols (인터넷 전송 프로토콜)](#22-internet-transport-protocols-인터넷-전송-프로토콜)
  - [3. Web and HTTP (웹과 HTTP)](#3-web-and-http-웹과-http)
    - [3.1 Web Basics (웹의 기본)](#31-web-basics-웹의-기본)
    - [3.2 HTTP Overview (HTTP 개요)](#32-http-overview-http-개요)
    - [3.3 Persistent vs Non-persistent Connections (지속/비지속 연결)](#33-persistent-vs-non-persistent-connections-지속비지속-연결)
    - [3.4 HTTP Message Format (HTTP 메시지 형식)](#34-http-message-format-http-메시지-형식)
    - [3.5 Cookies (쿠키)와 상태 유지](#35-cookies-쿠키와-상태-유지)
    - [3.6 Web Caching (웹 캐싱)](#36-web-caching-웹-캐싱)
  - [4. Electronic Mail (전자 메일)](#4-electronic-mail-전자-메일)
    - [4.1 Email System Components (이메일 시스템 구성)](#41-email-system-components-이메일-시스템-구성)
    - [4.2 SMTP 특징](#42-smtp-특징)
    - [4.3 Mail Access Protocols (메일 접근 프로토콜)](#43-mail-access-protocols-메일-접근-프로토콜)
  - [5. DNS (Domain Name System)](#5-dns-domain-name-system)
    - [5.1 DNS 제공 기능](#51-dns-제공-기능)
    - [5.2 DNS 구조: 분산/계층 데이터베이스](#52-dns-구조-분산계층-데이터베이스)
    - [5.3 DNS Query (DNS 질의)](#53-dns-query-dns-질의)
    - [5.4 DNS Caching (DNS 캐싱)](#54-dns-caching-dns-캐싱)
    - [5.5 DNS Records (DNS 레코드)](#55-dns-records-dns-레코드)
  - [6. Peer-to-Peer Applications (P2P 애플리케이션)](#6-peer-to-peer-applications-p2p-애플리케이션)
    - [6.1 P2P의 특징](#61-p2p의-특징)
    - [6.2 File Distribution 관점](#62-file-distribution-관점)
  - [7. Video Streaming and CDNs (비디오 스트리밍과 CDN)](#7-video-streaming-and-cdns-비디오-스트리밍과-cdn)
    - [7.1 스트리밍의 기본 이슈](#71-스트리밍의-기본-이슈)
    - [7.2 CDN (Content Delivery Network)](#72-cdn-content-delivery-network)
  - [8. Socket Programming with UDP and TCP (UDP/TCP 소켓 프로그래밍 개요)](#8-socket-programming-with-udp-and-tcp-udptcp-소켓-프로그래밍-개요)
    - [8.1 UDP 소켓](#81-udp-소켓)
    - [8.2 TCP 소켓](#82-tcp-소켓)
  - [9. Summary (요약)](#9-summary-요약)
- [Ch 3. Transport Layer (트랜스포트 계층)](#ch-3-transport-layer-트랜스포트-계층)
  - [1. Transport-Layer Services and Overview (전송 계층 서비스 개요)](#1-transport-layer-services-and-overview-전송-계층-서비스-개요)
    - [1.1 전송 계층이 제공하는 것](#11-전송-계층이-제공하는-것)
    - [1.2 Transport vs Network (전송 vs 네트워크)](#12-transport-vs-network-전송-vs-네트워크)
    - [1.3 Transport Protocols in the Internet](#13-transport-protocols-in-the-internet)
  - [2. Multiplexing and Demultiplexing (다중화/역다중화)](#2-multiplexing-and-demultiplexing-다중화역다중화)
    - [2.1 왜 필요한가?](#21-왜-필요한가)
    - [2.2 포트와 소켓 식별](#22-포트와-소켓-식별)
    - [2.3 Well-known Ports (대표 포트 예)](#23-well-known-ports-대표-포트-예)
  - [3. Connectionless Transport: UDP (비연결 전송: UDP)](#3-connectionless-transport-udp-비연결-전송-udp)
    - [3.1 UDP 서비스/특징](#31-udp-서비스특징)
    - [3.2 UDP가 유리한 상황](#32-udp가-유리한-상황)
    - [3.3 UDP 체크섬(Checksum)](#33-udp-체크섬checksum)
    - [3.4 UDP 세그먼트 헤더](#34-udp-세그먼트-헤더)
  - [4. Principles of Reliable Data Transfer (신뢰적 데이터 전송 원리)](#4-principles-of-reliable-data-transfer-신뢰적-데이터-전송-원리)
    - [4.1 핵심 아이디어(빌딩 블록)](#41-핵심-아이디어빌딩-블록)
    - [4.2 Stop-and-Wait (정지-대기) 개념](#42-stop-and-wait-정지-대기-개념)
    - [4.3 Pipelining (파이프라이닝)](#43-pipelining-파이프라이닝)
    - [4.4 Go-Back-N (GBN)](#44-go-back-n-gbn)
    - [4.5 Selective Repeat (SR)](#45-selective-repeat-sr)
  - [5. Connection-Oriented Transport: TCP (연결지향 전송: TCP)](#5-connection-oriented-transport-tcp-연결지향-전송-tcp)
    - [5.1 TCP가 제공하는 서비스](#51-tcp가-제공하는-서비스)
    - [5.2 TCP는 “바이트 스트림”이다](#52-tcp는-바이트-스트림이다)
  - [6. TCP Segment Structure (TCP 세그먼트 구조)](#6-tcp-segment-structure-tcp-세그먼트-구조)
    - [6.1 핵심 필드](#61-핵심-필드)
    - [6.2 MSS와 세그먼트 크기](#62-mss와-세그먼트-크기)
  - [7. TCP Reliable Data Transfer (TCP 신뢰성 메커니즘)](#7-tcp-reliable-data-transfer-tcp-신뢰성-메커니즘)
    - [7.1 누적 ACK (Cumulative ACK)](#71-누적-ack-cumulative-ack)
    - [7.2 재전송 트리거](#72-재전송-트리거)
    - [7.3 RTT 추정과 RTO(재전송 타이머)](#73-rtt-추정과-rto재전송-타이머)
    - [7.4 Sender/Receiver Buffering](#74-senderreceiver-buffering)
  - [8. TCP Flow Control (TCP 흐름 제어)](#8-tcp-flow-control-tcp-흐름-제어)
    - [8.1 목적](#81-목적)
    - [8.2 Receive Window (rwnd)](#82-receive-window-rwnd)
    - [8.3 (중요) Flow vs Congestion](#83-중요-flow-vs-congestion)
  - [9. TCP Connection Management (TCP 연결 관리)](#9-tcp-connection-management-tcp-연결-관리)
    - [9.1 3-way Handshake](#91-3-way-handshake)
    - [9.2 연결 종료](#92-연결-종료)
  - [10. Principles of Congestion Control (혼잡 제어 원리)](#10-principles-of-congestion-control-혼잡-제어-원리)
    - [10.1 혼잡이 생기면?](#101-혼잡이-생기면)
    - [10.2 혼잡 제어 접근](#102-혼잡-제어-접근)
    - [10.3 성능 목표](#103-성능-목표)
  - [11. TCP Congestion Control (TCP 혼잡 제어)](#11-tcp-congestion-control-tcp-혼잡-제어)
    - [11.1 Congestion Window (cwnd)](#111-congestion-window-cwnd)
    - [11.2 Slow Start (슬로 스타트)](#112-slow-start-슬로-스타트)
    - [11.3 Congestion Avoidance (혼잡 회피)](#113-congestion-avoidance-혼잡-회피)
    - [11.4 Loss Detection에 따른 반응](#114-loss-detection에-따른-반응)
    - [11.5 AIMD 직관](#115-aimd-직관)
  - [12. TCP Throughput and Fairness (처리율과 공정성)](#12-tcp-throughput-and-fairness-처리율과-공정성)
    - [12.1 TCP 처리율 직관](#121-tcp-처리율-직관)
    - [12.2 공정성(Fairness)](#122-공정성fairness)
  - [13. UDP vs TCP 선택 기준 (정리)](#13-udp-vs-tcp-선택-기준-정리)
  - [14. Summary (요약)](#14-summary-요약)
- [Ch 4. The Network Layer: Data Plane (네트워크 계층: 데이터 플레인)](#ch-4-the-network-layer-data-plane-네트워크-계층-데이터-플레인)
  - [1. Overview of Network Layer (네트워크 계층 개요)](#1-overview-of-network-layer-네트워크-계층-개요)
    - [1.1 Data Plane vs Control Plane](#11-data-plane-vs-control-plane)
    - [1.2 Forwarding vs Routing](#12-forwarding-vs-routing)
  - [2. The Router: Architecture and Functions (라우터: 구조와 기능)](#2-the-router-architecture-and-functions-라우터-구조와-기능)
    - [2.1 라우터의 기본 구성](#21-라우터의-기본-구성)
    - [2.2 Forwarding Table / Longest Prefix Match](#22-forwarding-table--longest-prefix-match)
    - [2.3 Switching Fabric 구현 방식](#23-switching-fabric-구현-방식)
    - [2.4 Queueing inside Routers (라우터 내부 큐잉)](#24-queueing-inside-routers-라우터-내부-큐잉)
    - [2.5 Packet Scheduling (패킷 스케줄링)](#25-packet-scheduling-패킷-스케줄링)
  - [3. The Internet Protocol (IP): IPv4 (인터넷 프로토콜: IPv4)](#3-the-internet-protocol-ip-ipv4-인터넷-프로토콜-ipv4)
    - [3.1 IP의 서비스 모델](#31-ip의-서비스-모델)
    - [3.2 IPv4 Datagram Format (IPv4 데이터그램 포맷)](#32-ipv4-datagram-format-ipv4-데이터그램-포맷)
    - [3.3 IPv4 Addressing (IPv4 주소)](#33-ipv4-addressing-ipv4-주소)
  - [4. Fragmentation (단편화)](#4-fragmentation-단편화)
    - [4.1 MTU와 단편화가 생기는 이유](#41-mtu와-단편화가-생기는-이유)
    - [4.2 IPv4 단편화 방식](#42-ipv4-단편화-방식)
  - [5. IPv4 to IPv6 (IPv4에서 IPv6로)](#5-ipv4-to-ipv6-ipv4에서-ipv6로)
    - [5.1 IPv6 동기](#51-ipv6-동기)
    - [5.2 IPv6 Datagram (IPv6 데이터그램) 특징](#52-ipv6-datagram-ipv6-데이터그램-특징)
    - [5.3 Transition Mechanisms (전환 메커니즘)](#53-transition-mechanisms-전환-메커니즘)
  - [6. Addressing in Practice: Subnets, DHCP, CIDR (주소/서브넷/할당)](#6-addressing-in-practice-subnets-dhcp-cidr-주소서브넷할당)
    - [6.1 Subnet (서브넷)](#61-subnet-서브넷)
    - [6.2 CIDR (Classless InterDomain Routing)](#62-cidr-classless-interdomain-routing)
    - [6.3 DHCP (Dynamic Host Configuration Protocol)](#63-dhcp-dynamic-host-configuration-protocol)
  - [7. NAT (Network Address Translation)](#7-nat-network-address-translation)
    - [7.1 NAT의 목적/배경](#71-nat의-목적배경)
    - [7.2 NAT 동작(포트 기반 변환)](#72-nat-동작포트-기반-변환)
    - [7.3 NAT의 논쟁점](#73-nat의-논쟁점)
  - [8. Generalized Forwarding and SDN (일반화된 포워딩과 SDN)](#8-generalized-forwarding-and-sdn-일반화된-포워딩과-sdn)
    - [8.1 전통적 포워딩 vs 일반화된 포워딩](#81-전통적-포워딩-vs-일반화된-포워딩)
    - [8.2 Match + Action (매치-액션) 관점](#82-match--action-매치-액션-관점)
    - [8.3 SDN (Software-Defined Networking) 연결고리](#83-sdn-software-defined-networking-연결고리)
  - [9. Summary (요약)](#9-summary-요약-1)
- [Ch 5. The Network Layer: Control Plane (네트워크 계층: 컨트롤 플레인)](#ch-5-the-network-layer-control-plane-네트워크-계층-컨트롤-플레인)
  - [1. Overview of the Control Plane (컨트롤 플레인 개요)](#1-overview-of-the-control-plane-컨트롤-플레인-개요)
    - [1.1 Control Plane의 역할](#11-control-plane의-역할)
  - [2. Routing vs Forwarding (라우팅과 포워딩)](#2-routing-vs-forwarding-라우팅과-포워딩)
  - [3. Routing Algorithms (라우팅 알고리즘)](#3-routing-algorithms-라우팅-알고리즘)
    - [3.1 경로 비용(Cost, Metric)](#31-경로-비용cost-metric)
  - [4. Link-State (LS) Routing Algorithm (링크 상태 알고리즘)](#4-link-state-ls-routing-algorithm-링크-상태-알고리즘)
    - [4.1 핵심 아이디어](#41-핵심-아이디어)
    - [4.2 LS의 동작 절차](#42-ls의-동작-절차)
    - [4.3 LS의 장단점](#43-ls의-장단점)
  - [5. Distance-Vector (DV) Routing Algorithm (거리 벡터 알고리즘)](#5-distance-vector-dv-routing-algorithm-거리-벡터-알고리즘)
    - [5.1 핵심 아이디어 (Bellman-Ford 기반)](#51-핵심-아이디어-bellman-ford-기반)
    - [5.2 DV의 동작 방식](#52-dv의-동작-방식)
    - [5.3 DV의 대표적 문제: Count-to-Infinity](#53-dv의-대표적-문제-count-to-infinity)
    - [5.4 완화 기법: Poisoned Reverse](#54-완화-기법-poisoned-reverse)
  - [6. LS vs DV 비교](#6-ls-vs-dv-비교)
  - [7. Hierarchical Routing (계층적 라우팅)](#7-hierarchical-routing-계층적-라우팅)
    - [7.1 AS(자율 시스템)](#71-as자율-시스템)
  - [8. Intra-AS Routing (AS 내부 라우팅) — RIP, OSPF](#8-intra-as-routing-as-내부-라우팅--rip-ospf)
    - [8.1 RIP (Routing Information Protocol)](#81-rip-routing-information-protocol)
    - [8.2 OSPF (Open Shortest Path First)](#82-ospf-open-shortest-path-first)
  - [9. Inter-AS Routing (AS 간 라우팅) — BGP](#9-inter-as-routing-as-간-라우팅--bgp)
    - [9.1 BGP의 중요성](#91-bgp의-중요성)
    - [9.2 BGP의 기본 개념](#92-bgp의-기본-개념)
    - [9.3 eBGP vs iBGP](#93-ebgp-vs-ibgp)
    - [9.4 BGP Path Selection (경로 선택 개요)](#94-bgp-path-selection-경로-선택-개요)
      - [Hot Potato Routing](#hot-potato-routing)
    - [9.5 Prefix Aggregation](#95-prefix-aggregation)
  - [10. SDN Control Plane (SDN 컨트롤 플레인)](#10-sdn-control-plane-sdn-컨트롤-플레인)
    - [10.1 전통적 모델: 라우터별 분산 제어](#101-전통적-모델-라우터별-분산-제어)
    - [10.2 SDN 모델: 논리적 중앙화](#102-sdn-모델-논리적-중앙화)
    - [10.3 SDN의 장점](#103-sdn의-장점)
  - [11. ICMP (Internet Control Message Protocol)](#11-icmp-internet-control-message-protocol)
    - [11.1 ICMP의 목적](#111-icmp의-목적)
    - [11.2 대표 메시지 유형](#112-대표-메시지-유형)
  - [12. Summary (요약)](#12-summary-요약)
- [Ch 6. The Link Layer and LANs (링크 계층과 LAN)](#ch-6-the-link-layer-and-lans-링크-계층과-lan)
  - [1. Introduction to the Link Layer (링크 계층 개요)](#1-introduction-to-the-link-layer-링크-계층-개요)
    - [1.1 링크 계층의 역할](#11-링크-계층의-역할)
    - [1.2 Nodes, Links, and Frames (노드·링크·프레임)](#12-nodes-links-and-frames-노드링크프레임)
    - [1.3 링크 계층이 구현되는 위치](#13-링크-계층이-구현되는-위치)
  - [2. Services Provided by the Link Layer (링크 계층 서비스)](#2-services-provided-by-the-link-layer-링크-계층-서비스)
    - [2.1 Framing (프레이밍)](#21-framing-프레이밍)
    - [2.2 Link Access (MAC) (링크 접근/MAC)](#22-link-access-mac-링크-접근mac)
    - [2.3 Reliable Delivery (신뢰적 전달) — 선택적](#23-reliable-delivery-신뢰적-전달--선택적)
    - [2.4 Error Detection/Correction (오류 검출/정정)](#24-error-detectioncorrection-오류-검출정정)
    - [2.5 Flow Control (흐름 제어) — 링크 단위](#25-flow-control-흐름-제어--링크-단위)
  - [3. Error Detection and Correction (오류 검출과 정정)](#3-error-detection-and-correction-오류-검출과-정정)
    - [3.1 오류의 원인과 목표](#31-오류의-원인과-목표)
    - [3.2 Error Detection: CRC (순환 중복 검사)](#32-error-detection-crc-순환-중복-검사)
    - [3.3 Error Correction: FEC (전방 오류 정정)](#33-error-correction-fec-전방-오류-정정)
  - [4. Multiple Access Links and Protocols (다중 접속 링크와 프로토콜)](#4-multiple-access-links-and-protocols-다중-접속-링크와-프로토콜)
    - [4.1 MAC Protocol의 분류](#41-mac-protocol의-분류)
    - [4.2 Random Access: CSMA/CD (이더넷의 고전적 방식)](#42-random-access-csmacd-이더넷의-고전적-방식)
    - [4.3 Random Access: CSMA/CA (무선에서의 충돌 회피)](#43-random-access-csmaca-무선에서의-충돌-회피)
  - [5. Switched Local Area Networks (스위치드 LAN)](#5-switched-local-area-networks-스위치드-lan)
    - [5.1 Link-Layer Addressing: MAC Address (MAC 주소)](#51-link-layer-addressing-mac-address-mac-주소)
    - [5.2 Ethernet (이더넷)](#52-ethernet-이더넷)
      - [5.2.1 Ethernet Frame Format (이더넷 프레임 포맷)](#521-ethernet-frame-format-이더넷-프레임-포맷)
    - [5.3 Link-Layer Switches (링크 계층 스위치)](#53-link-layer-switches-링크-계층-스위치)
      - [5.3.1 Filtering and Forwarding (필터링과 포워딩)](#531-filtering-and-forwarding-필터링과-포워딩)
    - [5.4 Switches vs Routers (스위치와 라우터 비교)](#54-switches-vs-routers-스위치와-라우터-비교)
  - [6. Virtual LANs (VLAN)](#6-virtual-lans-vlan)
    - [6.1 VLAN의 필요성](#61-vlan의-필요성)
    - [6.2 VLAN의 개념](#62-vlan의-개념)
    - [6.3 VLAN Tagging (802.1Q)](#63-vlan-tagging-8021q)
  - [7. Address Resolution Protocol (ARP)](#7-address-resolution-protocol-arp)
    - [7.1 ARP의 목적](#71-arp의-목적)
    - [7.2 ARP 동작 방식(개요)](#72-arp-동작-방식개요)
  - [8. Beyond Ethernet: Point-to-Point Links and MPLS (이더넷을 넘어)](#8-beyond-ethernet-point-to-point-links-and-mpls-이더넷을-넘어)
    - [8.1 Point-to-Point Protocol (PPP) — 개요](#81-point-to-point-protocol-ppp--개요)
    - [8.2 MPLS (Multi-Protocol Label Switching)](#82-mpls-multi-protocol-label-switching)
  - [9. Data Center Networking (데이터센터 네트워킹) — 개요](#9-data-center-networking-데이터센터-네트워킹--개요)
  - [10. Summary (요약)](#10-summary-요약)

---

# Ch 1. Computer Networks and the Internet (컴퓨터 네트워크와 인터넷)

> 큰 흐름: **Internet (인터넷)** 은 전 세계의 **End System (종단 시스템, 호스트)** 들이 **Communication Link (통신 링크)** 와 **Packet Switch (패킷 스위치: 라우터/스위치)** 로 연결된 “network of networks (네트워크들의 네트워크)” 이다. 핵심은 **Packet Switching (패킷 교환)**, **Protocol (프로토콜)**, **Layered Architecture (계층 구조)** 로 복잡도를 제어하면서, 지연/손실/처리율 같은 성능 지표를 이해하고 **Security (보안)** 과 **Application 요구사항** 까지 함께 보는 것이다.

---

## 1. What Is the Internet? (인터넷이란?)

### 1.1 구성요소 관점 (nuts-and-bolts view)

- **Host / End System (호스트/종단 시스템)**: PC, 서버, 스마트폰, IoT 등 네트워크의 “끝단”.
- **Communication Link (통신 링크)**: 광섬유, 동축, 구리선, 무선 등. 링크의 전송률은 **Transmission Rate / Bandwidth (전송률/대역폭, bps)** 로 표현.
- **Packet Switch (패킷 스위치)**: **Router (라우터)**, **Link-layer Switch (링크 계층 스위치)**. 패킷을 받아 다음 홉으로 전달(**Forwarding**)하고 경로를 선택(**Routing**)한다.
- **Packet (패킷)**: 데이터가 네트워크를 이동할 때 쪼개지는 단위(헤더 + 페이로드).
- **ISP (Internet Service Provider, 인터넷 서비스 제공자)**: 가정/기업/모바일 사용자를 인터넷에 연결하고, ISP들끼리도 계층적으로 연결된다.

### 1.2 서비스 관점 (service view)

- 인터넷은 애플리케이션에 **Communication Service (통신 서비스)** 를 제공한다.
- 앱은 **Socket (소켓)** 을 통해 네트워크로 데이터를 주고받는다.
- 대표 서비스 모델:
  - **TCP (Transmission Control Protocol)**: 연결지향, 신뢰적 전달, 혼잡제어.
  - **UDP (User Datagram Protocol)**: 비연결, 단순/빠름, 신뢰성은 앱이 책임.

### 1.3 프로토콜이란? (What is a protocol?)

- **Protocol (프로토콜)**: 메시지 형식, 주고받는 순서, 이벤트 발생 시 동작을 규정.
- 사람이 인사 규칙을 따르듯, 네트워크도 프로토콜로 상호운용성을 확보한다.

---

## 2. Network Edge (네트워크의 가장자리)

### 2.1 Access Network (접속 네트워크)

- 사용자가 ISP에 붙는 “마지막 구간”.
- 예시:
  - **DSL (Digital Subscriber Line)**, **Cable (케이블)**, **FTTH (Fiber To The Home)**
  - **Ethernet (이더넷)**, **Wi-Fi**
  - **Cellular (셀룰러: 4G/5G)**

### 2.2 Physical Media (물리 매체)

- **Guided Media (유선 매체)**: 꼬임선, 동축, 광섬유
- **Unguided Media (무선 매체)**: 전파/마이크로웨이브/위성 등
- 매체 특성은 대역폭, 잡음, 감쇠, 간섭 등에 영향을 준다.

---

## 3. Network Core (네트워크의 중심)

### 3.1 Packet Switching (패킷 교환)

- 데이터를 패킷으로 쪼개 각 패킷이 네트워크를 통과.
- 라우터는 일반적으로 **Store-and-Forward (저장 후 전달)**: 한 링크로 들어온 패킷을 저장한 후 다음 링크로 송신.
- **Queueing (큐잉)**: 출력 링크가 바쁘면 버퍼에서 대기 → 지연 증가.
- **Loss (손실)**: 버퍼가 가득 차면 패킷 드롭.

### 3.2 Circuit Switching (회선 교환)과 비교

- **Circuit Switching (회선 교환)**: 통신 전에 자원을 예약(대역폭/타임슬롯). 지연 예측이 쉽지만 유휴 시간에도 자원을 점유 → 비효율 가능.
- **Packet Switching**: 통계적 다중화(**Statistical Multiplexing**)로 평균 효율이 높지만, 혼잡 시 지연/손실 변동이 커질 수 있다.

### 3.3 Delay, Loss, Throughput (지연/손실/처리율)

- 노드에서의 지연 구성:
  - **Processing Delay (처리 지연)**: 헤더 검사, 오류 체크 등
  - **Queueing Delay (큐잉 지연)**: 버퍼 대기
  - **Transmission Delay (전송 지연)**: 패킷을 링크에 “밀어 넣는” 시간 = `L/R` (L=비트 길이, R=전송률)
  - **Propagation Delay (전파 지연)**: 신호가 매체를 따라 이동 = `d/s` (d=거리, s=전파속도)

- **End-to-End Delay (종단간 지연)**: 위 요소들의 합(경로상의 여러 홉 포함).
- **Throughput (처리율)**:
  - **Instantaneous Throughput (순간 처리율)** vs **Average Throughput (평균 처리율)**
  - 전체 경로는 보통 **Bottleneck Link (병목 링크)** 가 처리율을 제한.

---

## 4. Protocol Layers and Service Models (프로토콜 계층과 서비스 모델)

### 4.1 Layering (계층화)의 목적

- 복잡한 시스템을 계층으로 나눠 **모듈화**, **표준화**, **교체 용이성** 확보.
- 각 계층은 아래 계층의 서비스를 이용하고, 위 계층에 서비스를 제공한다.

### 4.2 Internet Protocol Stack (인터넷 5계층 스택)

- **Application Layer (응용 계층)**: HTTP, DNS, SMTP 등
- **Transport Layer (전송 계층)**: TCP, UDP
- **Network Layer (네트워크 계층)**: IP, 라우팅
- **Link Layer (링크 계층)**: Ethernet, Wi-Fi, LTE 링크 등
- **Physical Layer (물리 계층)**: 비트 신호 전송

### 4.3 Encapsulation (캡슐화)

- 상위 계층 데이터에 하위 계층 헤더(그리고 경우에 따라 트레일러)가 붙으며 내려감.
- 수신 측에서는 역순으로 헤더를 벗기며(**Decapsulation**) 처리.

### 4.4 OSI Model (OSI 7계층)과의 관계

- OSI는 7계층 참조모델(표현/세션 포함)로 교육적 의미가 크고,
- 실제 인터넷은 5계층 스택 중심으로 설명하는 경우가 많다.

---

## 5. Networks Under Attack (공격받는 네트워크)

### 5.1 대표 공격/위협

- **Malware (악성코드)**: 바이러스, 웜, 트로이목마, 랜섬웨어 등
- **DoS/DDoS (서비스 거부 공격)**: 대량 트래픽/요청으로 서비스 마비
- **Packet Sniffing (패킷 도청)**: 공유 매체/취약 구간에서 트래픽 엿보기
- **IP Spoofing (IP 스푸핑)**: 출발지 주소 위조

### 5.2 방어의 큰 방향

- **Authentication (인증)**, **Confidentiality (기밀성: 암호화)**, **Integrity (무결성)**, **Availability (가용성)**
- 네트워크는 “처음부터 신뢰”가 아니라, 설계/운영 전반에서 보안을 고려해야 한다.

---

## 6. Summary (요약)

- 인터넷은 **호스트-링크-라우터-ISP** 로 이루어진 거대한 **네트워크들의 네트워크**이며, **프로토콜**로 동작한다.
- **패킷 교환**은 통계적 다중화로 효율적이지만 혼잡 시 **지연/손실**이 발생한다(회선 교환과 대비).
- 성능은 **처리/큐잉/전송/전파 지연**, **손실**, **처리율(병목)** 로 분석한다.
- **계층 구조(5계층)** 와 **캡슐화** 는 복잡도를 낮추고 상호운용성을 만든다.
- 현실의 인터넷은 항상 공격 표면을 가지므로, 기본 위협(DoS, 스니핑, 스푸핑, 멀웨어)을 알고 방어 목표를 이해해야 한다.

# Ch 2. Application Layer (애플리케이션 계층)

> 큰 흐름: **Application Layer (애플리케이션 계층)** 은 네트워크 앱이 **End System (종단 시스템)** 위에서 동작하도록 **Application Protocol (애플리케이션 프로토콜)** 을 정의한다. 핵심은 **Client–Server / P2P (클라이언트–서버 / P2P)** 구조, **Socket API (소켓 인터페이스)**, **Transport Service 요구사항(신뢰성/지연/처리율/보안)**, 그리고 대표 프로토콜인 **HTTP, DNS, Email(SMTP/IMAP/POP3)**, **CDN** 개념이다.

---

## 1. Principles of Network Applications (네트워크 애플리케이션의 원리)

### 1.1 Application Architecture (애플리케이션 구조)

- **Client–Server Architecture (클라이언트–서버 구조)**
  - 항상 켜져 있는 **Server (서버)** 가 고정 주소(또는 안정적인 도메인)를 가진다.
  - **Client (클라이언트)** 는 서버에 접속 요청을 보내고 서비스를 받는다.
  - 예: 웹, 이메일(서버 기반), 클라우드 서비스.

- **Peer-to-Peer (P2P) Architecture (피어-투-피어 구조)**
  - 피어가 클라이언트이면서 서버 역할도 수행.
  - 확장성(피어가 늘수록 자원도 늘 수 있음)이 장점이지만 관리/보안/NAT 문제 등 복잡도가 증가.
  - 예: 일부 파일 공유/분산 앱.

- **Hybrid (혼합형)**
  - 로그인/검색은 서버, 데이터 전송은 P2P 등 혼합 설계가 흔하다.

### 1.2 Process Communicating (프로세스 통신)

- 네트워크 앱은 여러 **Process (프로세스)** 가 서로 메시지를 주고받는다.
- 동일 호스트 내부는 IPC로 충분하지만, 다른 호스트 간 통신은 네트워크가 필요.

### 1.3 Sockets (소켓)

- **Socket (소켓)**: 애플리케이션이 네트워크로 데이터를 주고받는 “문(door)”.
- 앱은 소켓에 데이터를 **send/receive** 하고, 아래 계층(전송/네트워크)이 실제 전달을 담당.

### 1.4 Addressing (주소 지정)

- 프로세스를 식별하려면 보통:
  - **IP Address (IP 주소)**: 호스트 식별
  - **Port Number (포트 번호)**: 호스트 내 프로세스(서비스) 식별

---

## 2. Transport Services the Application Needs (전송 계층 서비스 요구사항)

### 2.1 데이터 전달 관점

- **Reliable Data Transfer (신뢰적 전송)**
  - 데이터 손실이 허용되지 않는 앱(파일 전송, 이메일, 웹 페이지의 기본 전송 등)은 신뢰성이 중요.

- **Throughput (처리율/대역 요구)**
  - 일정 이상의 처리율이 필요(스트리밍 고화질, 대용량 전송 등)할 수 있음.
  - 반대로 “최소 처리율 보장”이 없더라도 적응형 비트레이트처럼 앱이 적응할 수도 있다.

- **Timing / Delay (지연 요구)**
  - 실시간성(VoIP, 온라인 게임)은 낮은 지연이 중요.

- **Security (보안)**
  - **Confidentiality (기밀성)**, **Integrity (무결성)**, **Authentication (인증)** 등이 필요할 수 있음.
  - 전송 계층 위의 **TLS** 같은 방식으로 제공되는 경우가 많다.

### 2.2 Internet Transport Protocols (인터넷 전송 프로토콜)

- **TCP (Transmission Control Protocol)**
  - 연결지향, 신뢰적 전송, 혼잡 제어.
  - 바이트 스트림 기반(메시지 경계는 앱이 관리).

- **UDP (User Datagram Protocol)**
  - 비연결, 신뢰성/순서 보장 없음, 오버헤드가 작음.
  - 메시지(데이터그램) 단위.

---

## 3. Web and HTTP (웹과 HTTP)

### 3.1 Web Basics (웹의 기본)

- **Web Page (웹 페이지)** 는 여러 **Object (오브젝트)** 로 구성(HTML, 이미지, JS, CSS 등).
- 각 오브젝트는 **URL** 로 식별된다.

### 3.2 HTTP Overview (HTTP 개요)

- **HTTP (HyperText Transfer Protocol)**: 웹의 대표 **Application Protocol**.
- **Client (브라우저)** 가 **HTTP Request**, **Server (웹 서버)** 가 **HTTP Response**.
- **Stateless (무상태)**: 서버는 기본적으로 클라이언트의 “이전 요청 상태”를 저장하지 않는다.

### 3.3 Persistent vs Non-persistent Connections (지속/비지속 연결)

- **Non-persistent HTTP (비지속 HTTP)**
  - 오브젝트마다 TCP 연결을 새로 맺고 끊는 방식.
  - 지연/오버헤드 증가.

- **Persistent HTTP (지속 HTTP)**
  - 하나의 TCP 연결을 유지하며 여러 오브젝트를 연속 요청.
  - 성능 개선(연결 설정 비용 감소).

### 3.4 HTTP Message Format (HTTP 메시지 형식)

- **Request Message**: 요청 라인(method, URL path, version) + 헤더들 + (옵션) 바디
  - 대표 메서드: **GET, POST, HEAD, PUT, DELETE** 등

- **Response Message**: 상태 라인(status code) + 헤더들 + 바디
  - 대표 상태코드: **200 OK, 301 Moved Permanently, 400 Bad Request, 404 Not Found, 505 HTTP Version Not Supported** 등

### 3.5 Cookies (쿠키)와 상태 유지

- HTTP는 무상태지만, 로그인/세션 같은 상태를 위해 **Cookie (쿠키)** 를 사용.
- 쿠키로 사용자 식별자를 저장하면 서버는 그 식별자로 사용자 상태를 간접적으로 관리 가능.

### 3.6 Web Caching (웹 캐싱)

- **Web Cache / Proxy (웹 캐시/프록시)**: 원 서버 대신 자주 요청되는 오브젝트를 저장해 제공.
- 장점: 응답 시간 감소, 백본/서버 부하 감소.
- **Conditional GET (조건부 GET)** 같은 기법으로 최신성 검증을 한다.

---

## 4. Electronic Mail (전자 메일)

### 4.1 Email System Components (이메일 시스템 구성)

- **User Agent (사용자 에이전트)**: 사용자가 메일을 읽고 쓰는 클라이언트.
- **Mail Server (메일 서버)**: 메일박스 관리/전달.
- **SMTP (Simple Mail Transfer Protocol)**: 메일 서버 간(또는 클라이언트→서버) 메일 전송.

### 4.2 SMTP 특징

- 기본적으로 **push (푸시)** 방식(보내는 쪽이 밀어 넣는다).
- 메시지 본문은 전통적으로 ASCII 기반이며, 첨부는 보통 **MIME** 로 처리.

### 4.3 Mail Access Protocols (메일 접근 프로토콜)

- 수신자가 서버에서 메일을 가져오거나 동기화:
  - **POP3**: 단순 다운로드 중심
  - **IMAP**: 서버에 메일을 두고 폴더/동기화 지원
  - (현실에선 HTTP 기반 웹메일도 흔함)

---

## 5. DNS (Domain Name System)

> DNS는 ‘인터넷의 전화번호부’ 역할: **Host Name (호스트 이름)** 을 **IP Address** 로 변환한다.

### 5.1 DNS 제공 기능

- **Name-to-IP Translation (이름→IP 변환)**
- **Host Aliasing (호스트 별칭)**: canonical name ↔ alias name
- **Mail Server Aliasing (메일 서버 별칭)**
- **Load Distribution (부하 분산)**: 여러 IP를 반환해 트래픽 분산

### 5.2 DNS 구조: 분산/계층 데이터베이스

- 단일 중앙 DB가 아니라, 확장성과 관리성을 위해 **Hierarchical (계층적)** + **Distributed (분산)**.
- 대표 계층:
  - **Root DNS Servers (루트 DNS)**
  - **TLD DNS Servers (최상위 도메인 DNS)**
  - **Authoritative DNS Servers (권한 DNS)**

- 조직/ISP는 보통 **Local DNS Resolver (로컬 DNS 리졸버)** 를 통해 질의한다.

### 5.3 DNS Query (DNS 질의)

- **Recursive Query (재귀 질의)**: 리졸버가 결과를 끝까지 받아 사용자에게 전달.
- **Iterative Query (반복 질의)**: 다음에 물어볼 서버 정보를 받아가며 순차 탐색.

### 5.4 DNS Caching (DNS 캐싱)

- 질의 결과를 일정 시간(**TTL**) 저장해 지연과 트래픽을 줄인다.
- 캐시로 인해 변경 전파가 즉시 반영되지 않을 수 있다.

### 5.5 DNS Records (DNS 레코드)

- 일반적으로 (Name, Value, Type, TTL) 형태.
- 대표 타입:
  - **A**: hostname → IPv4
  - **AAAA**: hostname → IPv6
  - **NS**: 도메인의 권한 DNS 서버
  - **CNAME**: 별칭 → 정식 이름
  - **MX**: 메일 서버

---

## 6. Peer-to-Peer Applications (P2P 애플리케이션)

### 6.1 P2P의 특징

- 서버 의존도를 줄이고 피어들이 자원을 제공.
- 장점: 확장성, 비용 분산 가능
- 단점: 피어 가용성 변동, NAT/방화벽 이슈, 보안/신뢰 문제

### 6.2 File Distribution 관점

- 전통적 클라이언트–서버는 서버 업로드가 병목이 되기 쉽다.
- P2P는 피어가 늘면 전체 업로드 자원도 늘어 분배 시간이 줄어들 수 있다(이상적인 경우).

---

## 7. Video Streaming and CDNs (비디오 스트리밍과 CDN)

### 7.1 스트리밍의 기본 이슈

- 네트워크 처리율 변동, 지연, 손실로 인해 끊김이 발생할 수 있음.
- 해결 방향: 버퍼링, 적응형 비트레이트 등.

### 7.2 CDN (Content Delivery Network)

- 전 세계에 분산된 서버에 콘텐츠를 복제해 사용자와 가까운 곳에서 제공.
- 목표: 지연 감소, 트래픽 분산, 원 서버 부하 감소.
- DNS를 이용해 “가까운/적절한” CDN 노드로 유도하는 방식이 흔하다.

---

## 8. Socket Programming with UDP and TCP (UDP/TCP 소켓 프로그래밍 개요)

### 8.1 UDP 소켓

- 비연결: 송신은 바로 send, 수신은 recv.
- 신뢰성/순서/재전송은 앱이 필요 시 구현.

### 8.2 TCP 소켓

- 연결지향: **3-way handshake** 로 연결 설정 후 데이터 송수신.
- 서버는 보통:
  - **Welcome Socket** 으로 연결 요청을 받고,
  - 연결마다 별도 소켓을 만들어 다중 클라이언트를 처리.

---

## 9. Summary (요약)

- 애플리케이션 계층은 **앱 구조(클라-서버/P2P)** 와 **프로토콜(HTTP/DNS/Email)** 로 인터넷 서비스를 만든다.
- 앱은 **소켓** 을 통해 전송 계층 서비스를 사용하며, 요구사항(신뢰성/지연/처리율/보안)에 따라 **TCP/UDP** 를 선택한다.
- 웹은 **HTTP(무상태)** 를 기반으로 하며, **지속 연결, 쿠키, 캐싱** 으로 성능/상태 문제를 해결한다.
- DNS는 분산 계층 구조로 **이름→IP 변환**, 캐싱(TTL), 레코드 타입(A/AAAA/NS/CNAME/MX) 등을 제공한다.
- 스트리밍은 처리율 변동을 다루기 위해 버퍼링/적응을 사용하고, **CDN** 으로 지연과 부하를 줄인다.

# Ch 3. Transport Layer (트랜스포트 계층)

> 큰 흐름: **Transport Layer (트랜스포트 계층)** 은 서로 다른 호스트에서 실행되는 애플리케이션 **process-to-process** 통신을 제공한다. 핵심은 (1) **Multiplexing/Demultiplexing (다중화/역다중화)** 로 “어느 프로세스에게 줄 데이터인가”를 해결하고, (2) **Reliable Data Transfer (신뢰적 전송)** 을 end-to-end로 구현하며, (3) **TCP** 가 **Flow Control (흐름제어)** 과 **Congestion Control (혼잡제어)** 로 성능/안정성을 확보하는 것이다.

---

## 1. Transport-Layer Services and Overview (전송 계층 서비스 개요)

### 1.1 전송 계층이 제공하는 것

- **Process-to-Process Delivery (프로세스 간 전달)**
  - 네트워크 계층(IP)이 “호스트까지” 보내면,
  - 전송 계층이 “호스트 내부의 특정 프로세스(소켓)까지” 전달한다.

- **Segmentation / Reassembly (분할/재조립)**
  - 애플리케이션 메시지를 전송 단위인 **Segment (세그먼트)** 로 쪼개고, 수신 측에서 재조립.

- (TCP의 경우) **Reliable, In-order Delivery (신뢰적/순서 보장 전달)**
- (TCP의 경우) **Flow Control / Congestion Control**

### 1.2 Transport vs Network (전송 vs 네트워크)

- **Network Layer (IP)**: best-effort로 패킷을 목적지 호스트까지 운반(손실/재정렬 가능).
- **Transport Layer**: end system에서만 동작하며, 앱이 원하는 “서비스 품질”을 프로토콜(TCP/UDP)로 제공.

### 1.3 Transport Protocols in the Internet

- **UDP**: 비연결, 단순, 최소 기능(체크섬 + 포트 기반 전달)
- **TCP**: 연결지향, 신뢰적 바이트 스트림, 흐름/혼잡 제어

---

## 2. Multiplexing and Demultiplexing (다중화/역다중화)

### 2.1 왜 필요한가?

- 한 호스트에서 브라우저/게임/메신저 등 여러 앱이 동시에 통신.
- 전송 계층은:
  - 송신: 여러 소켓에서 나온 데이터를 **하나의 전송 계층**이 받아 세그먼트로 만들고(**Multiplexing**)
  - 수신: 도착한 세그먼트를 **올바른 소켓**으로 보내야 한다(**Demultiplexing**)

### 2.2 포트와 소켓 식별

- **Port Number (포트 번호)**: 호스트 내부 프로세스(서비스) 식별.
- **UDP Demux**
  - 주로 **Destination Port** 로 소켓을 결정(단일 소켓이 여러 송신자를 받을 수 있음).

- **TCP Demux**
  - 연결마다 소켓이 분리되며 일반적으로 **4-tuple** 로 구분:
  - (Source IP, Source Port, Destination IP, Destination Port)

### 2.3 Well-known Ports (대표 포트 예)

- HTTP 80, HTTPS 443, DNS 53, SMTP 25 등(개념 이해 목적).

---

## 3. Connectionless Transport: UDP (비연결 전송: UDP)

### 3.1 UDP 서비스/특징

- **Connectionless**: 핸드셰이크 없이 즉시 전송.
- **No reliability / No ordering / No congestion control**
- **Low overhead**: 헤더가 작고(단순), 구현/상태 관리가 거의 없음.

### 3.2 UDP가 유리한 상황

- **지연이 중요**하거나(핸드셰이크/재전송 부담 회피)
- **애플리케이션이 자체적으로 신뢰성/전송률을 제어**하는 경우
- **단순 질의/응답** 패턴(DNS 같은 작은 요청/응답)에서 오버헤드가 부담일 때

### 3.3 UDP 체크섬(Checksum)

- 목적: 전송 중 비트 오류 검출.
- 인터넷에서는 링크 계층이 오류를 잡더라도 “종단 간” 안전을 위해 전송 계층에서도 오류 검출을 둔다.

### 3.4 UDP 세그먼트 헤더

- **Source Port / Destination Port**
- **Length**
- **Checksum**

---

## 4. Principles of Reliable Data Transfer (신뢰적 데이터 전송 원리)

> 목표: 손실/오류/재정렬이 가능한 네트워크 위에서 “마치 완벽한 채널처럼” 동작하는 서비스를 end-to-end로 만든다.

### 4.1 핵심 아이디어(빌딩 블록)

- **Error detection**: 체크섬
- **Receiver feedback**: ACK/NAK(개념), TCP는 ACK 중심
- **Retransmission**: 손실 추정 시 재전송
- **Sequence numbers**: 중복/순서 뒤바뀜 처리
- **Timers**: ACK가 오지 않으면 타임아웃 후 재전송

### 4.2 Stop-and-Wait (정지-대기) 개념

- 한 번에 하나 보내고 ACK 기다림 → 단순하지만 링크가 길거나 대역이 클수록 비효율.
- 효율 직관:
  - 왕복시간(RTT)이 크면 “기다리는 시간”이 커져 처리율이 떨어짐.

### 4.3 Pipelining (파이프라이닝)

- 여러 패킷을 연속으로 보내 “대기 시간을 숨김”.
- 파이프라이닝을 위해 필요한 것:
  - **송신 윈도우**(ACK 전까지 보낼 수 있는 범위)
  - **버퍼링**(미확인 데이터 저장)

### 4.4 Go-Back-N (GBN)

- 송신자는 윈도우 내 여러 패킷을 보냄.
- 수신자는 **in-order**만 수용하고, 누락 발생 시 그 이후는 버림.
- ACK는 보통 **누적 ACK(cumulative ACK)**.
- 손실 시: “누락된 패킷부터 이후 모두” 재전송 → 단순하지만 낭비 가능.

### 4.5 Selective Repeat (SR)

- 수신자는 out-of-order도 버퍼링.
- 송신자는 **개별 패킷 단위**로 ACK/타이머 관리.
- 손실 시: 누락된 것만 재전송 → 효율적이지만 상태/복잡도 증가.

---

## 5. Connection-Oriented Transport: TCP (연결지향 전송: TCP)

### 5.1 TCP가 제공하는 서비스

- **Reliable, in-order byte stream (신뢰적/순서 보장 바이트 스트림)**
- **Full-duplex (전이중)**: 양방향 동시에 데이터 가능
- **Point-to-point (1:1)**: 멀티캐스트 아님
- **Flow control** + **Congestion control**

### 5.2 TCP는 “바이트 스트림”이다

- UDP는 메시지 단위(데이터그램) 경계가 유지되는 반면,
- TCP는 애플리케이션이 쓴 바이트 흐름을 연속적으로 전달.
- 메시지 경계는 애플리케이션 프로토콜(예: HTTP)에서 처리.

---

## 6. TCP Segment Structure (TCP 세그먼트 구조)

### 6.1 핵심 필드

- **Source Port / Destination Port**
- **Sequence Number (Seq)**
  - “세그먼트에 담긴 데이터의 첫 바이트 번호”

- **Acknowledgment Number (Ack)**
  - “다음에 기대하는 바이트 번호”(누적 ACK)

- **Header Length**
- **Flags**
  - **SYN**(연결 설정), **FIN**(연결 종료), **ACK**, **RST**, **PSH**, **URG**

- **Receive Window (rwnd)**
- **Checksum**
- **Options**
  - 예: MSS, 윈도우 확장, SACK 옵션 등(개념적으로)

### 6.2 MSS와 세그먼트 크기

- **MSS (Maximum Segment Size)**: TCP payload 최대 크기(대략 MTU에서 IP/TCP 헤더를 뺀 값).

---

## 7. TCP Reliable Data Transfer (TCP 신뢰성 메커니즘)

### 7.1 누적 ACK (Cumulative ACK)

- 수신자는 “연속으로 받은 마지막 바이트 이후”를 ACK.
- 장점: ACK 관리 단순.
- 단점: 중간 손실이 있어도 이후 도착한 out-of-order 데이터는 누적 ACK에 반영되지 않음.

### 7.2 재전송 트리거

- **Timeout (타임아웃)**: ACK가 일정 시간 안 오면 손실로 간주.
- **Duplicate ACKs (중복 ACK)**
  - 같은 ACK 번호가 반복되면 “중간에 빠진 세그먼트가 있다” 신호.
  - 보통 **3 duplicate ACK** → **Fast Retransmit (빠른 재전송)**

### 7.3 RTT 추정과 RTO(재전송 타이머)

- TCP는 네트워크 상황이 변하므로 타임아웃을 고정하면 위험.
- 아이디어:
  - **SampleRTT** 측정 → **EstimatedRTT** 를 지수평활로 갱신
  - 변동성까지 고려한 **DevRTT** 를 함께 추정
  - **RTO = EstimatedRTT + 4 \* DevRTT** 형태로 설정(대표적인 형태)

- 타임아웃 재전송 후에는 타이머를 키우는 **exponential backoff** 를 적용하는 것이 일반적.

### 7.4 Sender/Receiver Buffering

- 송신자는 미확인 데이터(재전송 대비)를 버퍼에 저장.
- 수신자는 순서대로 앱에 전달하기 위해 버퍼를 사용(특히 out-of-order 수용 시).

---

## 8. TCP Flow Control (TCP 흐름 제어)

### 8.1 목적

- 송신자가 너무 빨리 보내 수신자 버퍼가 넘치는 것을 방지.

### 8.2 Receive Window (rwnd)

- 수신자는 현재 버퍼 여유를 **rwnd** 로 광고(advertise).
- 송신자는 미확인 데이터 양을 대략 `<= rwnd` 로 제한.

### 8.3 (중요) Flow vs Congestion

- **Flow control**: 수신자 보호(수신 버퍼/처리 능력)
- **Congestion control**: 네트워크 보호(라우터 큐/링크 혼잡)
- TCP 송신 제한은 보통 `min(rwnd, cwnd)` 관점으로 이해.

---

## 9. TCP Connection Management (TCP 연결 관리)

### 9.1 3-way Handshake

1. Client → Server: **SYN** (초기 Seq 제안)
2. Server → Client: **SYN+ACK**
3. Client → Server: **ACK**

- 목적: 양쪽 초기 시퀀스 번호 동기화 + 연결 상태 확립.

### 9.2 연결 종료

- 일반적으로 **FIN** 기반으로 각 방향을 독립적으로 종료(half-close 가능).
- 종료 과정은 상태 전이(TIME_WAIT 등)를 동반.

---

## 10. Principles of Congestion Control (혼잡 제어 원리)

### 10.1 혼잡이 생기면?

- 라우터 큐가 길어짐 → **Queueing delay 증가**
- 버퍼가 가득 차면 **패킷 손실(drop)**
- 재전송이 늘면 더 혼잡해지는 악순환 가능.

### 10.2 혼잡 제어 접근

- **End-to-end**: 네트워크가 명시적 신호를 주지 않아도, 종단에서 손실/지연을 보고 추정(TCP 기본 철학)
- **Network-assisted**: 라우터가 혼잡을 표시(ECN 같은 개념)

### 10.3 성능 목표

- 높은 처리율, 낮은 지연, 공정한 공유.

---

## 11. TCP Congestion Control (TCP 혼잡 제어)

> 큰 줄기: **AIMD** 기반으로 cwnd를 조절하며, 손실(또는 혼잡 신호) 시 크게 줄이고, 혼잡이 없으면 늘린다.

### 11.1 Congestion Window (cwnd)

- 송신자가 네트워크 혼잡을 고려해 설정하는 “네트워크 관점의 송신 윈도우”.
- 실전 송신 가능량(미확인 데이터)은 대략 `min(cwnd, rwnd)`.

### 11.2 Slow Start (슬로 스타트)

- 연결 시작 시 cwnd를 작게 두고 **지수적 증가**(RTT마다 2배 수준)로 가용 대역을 탐색.
- **ssthresh** 를 기준으로 다음 단계 전환.

### 11.3 Congestion Avoidance (혼잡 회피)

- cwnd를 **선형 증가**(RTT당 대략 1 MSS)로 안정적으로 확장.

### 11.4 Loss Detection에 따른 반응

- **Timeout loss** (더 심각한 혼잡으로 간주)
  - cwnd를 크게 줄이고(초기화 수준), slow start로 돌아가는 흐름이 흔함.

- **Triple duplicate ACK loss** (상대적으로 덜 심각)
  - **Fast retransmit** + **빠른 회복(빠른 재전송 후 cwnd를 덜 극단적으로 감소)**
  - (구체 구현은 TCP Reno 계열에서 강조)

### 11.5 AIMD 직관

- 혼잡 없으면 천천히(+1) 늘려 안정적으로 공유
- 혼잡 시 절반(×1/2) 줄여 네트워크를 빠르게 진정

---

## 12. TCP Throughput and Fairness (처리율과 공정성)

### 12.1 TCP 처리율 직관

- 처리율은 대략 **cwnd / RTT** 규모로 생각할 수 있다.
- 손실 이벤트가 자주 나면 cwnd가 자주 줄어 평균 처리율이 낮아짐.

### 12.2 공정성(Fairness)

- 동일 병목을 공유하는 여러 TCP 연결은(이상적 가정에서) 대역을 비슷하게 나누는 경향.
- 하지만:
  - RTT가 큰 연결은 불리할 수 있고,
  - 한 애플리케이션이 여러 TCP 연결을 만들면 더 많은 몫을 가져갈 수 있다.

---

## 13. UDP vs TCP 선택 기준 (정리)

- **UDP**
  - 지연/단순성 우선, 앱이 제어, 오버헤드 최소
  - 신뢰성/혼잡제어는 앱 책임

- **TCP**
  - 신뢰성, 순서 보장, 흐름/혼잡 제어가 필요할 때
  - 연결 관리/오버헤드가 있지만 일반적인 데이터 전송의 기본 선택지

---

## 14. Summary (요약)

- 전송 계층은 **포트 기반 다중화/역다중화**로 프로세스 간 전달을 제공한다.
- **UDP** 는 비연결·저오버헤드이며 기본 전달/오류검출만 제공한다.
- **신뢰적 전송**은 시퀀스 번호, ACK, 재전송, 타이머, 파이프라이닝(GBN/SR) 같은 메커니즘으로 구현된다.
- **TCP** 는 바이트 스트림 형태로 신뢰성을 제공하며, **RTT 추정/RTO**, **Fast Retransmit** 등으로 성능을 개선한다.
- **Flow control(rwnd)** 은 수신자 보호, **Congestion control(cwnd, AIMD)** 은 네트워크 보호이며 실제 송신량은 `min(rwnd, cwnd)` 관점으로 이해한다.
- TCP 혼잡 제어는 **Slow Start → Congestion Avoidance → (Fast Retransmit/Recovery)** 흐름으로 가용 대역을 탐색하고 혼잡 시 빠르게 감소한다.

---

# Ch 4. The Network Layer: Data Plane (네트워크 계층: 데이터 플레인)

> 큰 흐름: **Network Layer (네트워크 계층)** 은 패킷을 출발지 호스트에서 목적지 호스트로 전달한다. 4장은 그중에서도 라우터 내부에서 “패킷 한 개를 어떻게 처리해 다음 홉으로 넘기는가”에 집중하는 **Data Plane (데이터 플레인)** 을 다룬다. 핵심은 **Forwarding (포워딩)**, **Router Architecture (라우터 구조)**, **IP Datagram (IP 데이터그램) 포맷과 IPv4/IPv6**, **Fragmentation (단편화)**, **NAT**, 그리고 **Generalized Forwarding/SDN** 관점이다.

---

## 1. Overview of Network Layer (네트워크 계층 개요)

### 1.1 Data Plane vs Control Plane

- **Data Plane (데이터 플레인)**
  - 라우터가 도착한 패킷을 보고 **입력 포트 → 출력 포트**로 넘기는 로컬 동작.
  - 핵심 동작: **Forwarding**.

- **Control Plane (컨트롤 플레인)**
  - 패킷이 어떤 경로로 가야 하는지 **Routing (라우팅)** 을 결정.
  - 5장에서 라우팅 알고리즘/프로토콜을 다룸.

### 1.2 Forwarding vs Routing

- **Forwarding (포워딩)**: 라우터 한 대 내부에서 “다음 홉으로” 내보내는 동작(짧은 시간 스케일).
- **Routing (라우팅)**: 네트워크 전체 관점에서 경로를 선택(긴 시간 스케일).

---

## 2. The Router: Architecture and Functions (라우터: 구조와 기능)

### 2.1 라우터의 기본 구성

- **Input Ports (입력 포트)**
  - 물리 계층/링크 계층 처리
  - **Lookup/Forwarding Table 검색**
  - 입력 큐(혼잡 시 대기)

- **Switching Fabric (스위칭 패브릭)**
  - 입력 포트에서 출력 포트로 패킷을 옮기는 내부 스위치

- **Output Ports (출력 포트)**
  - 출력 큐(대기)
  - 링크 계층 프레이밍 후 전송

- **Routing Processor (라우팅 프로세서)**
  - 컨트롤 플레인 기능 수행(라우팅 프로토콜, 테이블 관리)

### 2.2 Forwarding Table / Longest Prefix Match

- 라우터는 목적지 IP 주소를 보고 **Forwarding Table** 을 조회해 출력 포트를 결정.
- IP는 계층적 주소(프리픽스 기반)이므로:
  - 여러 항목이 매칭될 수 있고, 가장 구체적인 경로가 우선 → **Longest Prefix Match (최장 프리픽스 매칭)**.

### 2.3 Switching Fabric 구현 방식

- **Memory-based (메모리 기반)**
  - CPU/메모리를 통해 복사하며 전달(초기 라우터 방식). 메모리 대역이 병목.

- **Bus-based (버스 기반)**
  - 공유 버스를 통해 전달. 버스 대역이 병목.

- **Interconnection Network / Crossbar (상호연결망/크로스바)**
  - 병렬 전송에 유리, 고성능 라우터에서 흔함.

### 2.4 Queueing inside Routers (라우터 내부 큐잉)

- 입력/출력 링크 속도 불일치나 트래픽 버스트로 큐가 생김.
- **Input Queueing (입력 큐잉)**
  - 여러 입력이 같은 출력으로 가려면 대기 발생.
  - 대표 문제: **HOL Blocking (Head-of-Line 블로킹)**
    - 큐 맨 앞 패킷이 막히면 뒤 패킷도 못 지나감.

- **Output Queueing (출력 큐잉)**
  - 출력 링크가 바쁠 때 출력 버퍼에서 대기.

- **Buffer Overflow → Packet Loss (버퍼 초과 → 손실)**

### 2.5 Packet Scheduling (패킷 스케줄링)

- 출력 링크로 어떤 순서로 내보낼지 결정.
- 대표 정책:
  - **FIFO**: 단순, 공정성/지연 제어 한계
  - **Priority Scheduling (우선순위)**: 우선순위 높은 트래픽 지연 감소(낮은 쪽 starvation 위험)
  - **Round Robin / Weighted Round Robin (RR/WRR)**: 흐름/클래스 간 공정성 개선

---

## 3. The Internet Protocol (IP): IPv4 (인터넷 프로토콜: IPv4)

### 3.1 IP의 서비스 모델

- **Best-effort delivery (최선형 서비스)**
  - 지연 보장 없음
  - 손실/재정렬 가능
  - 대역 보장 없음

- 따라서 신뢰성/순서 보장은 전송 계층(TCP)이나 애플리케이션이 담당.

### 3.2 IPv4 Datagram Format (IPv4 데이터그램 포맷)

- 핵심 필드(의미 위주):
  - **Version**: IPv4
  - **Header Length (IHL)**: 헤더 길이
  - **Type of Service (ToS) / DSCP**: QoS 분류용
  - **Total Length**: 전체 길이
  - **Identification / Flags / Fragment Offset**: 단편화 관련
  - **TTL (Time To Live)**: 홉마다 감소, 0이면 폐기(루프 방지)
  - **Protocol**: 상위 전송 프로토콜(TCP=6, UDP=17 등)
  - **Header Checksum**: 헤더 오류 검출(홉마다 재계산)
  - **Source IP / Destination IP**
  - **Options (옵션)**: 가변(현대 인터넷에서는 제한적으로 사용)

### 3.3 IPv4 Addressing (IPv4 주소)

- **32-bit 주소**.
- 계층적 구조(네트워크 프리픽스 + 호스트 부분).
- 표기: 점-10진 표기(예: 128.119.40.186).

---

## 4. Fragmentation (단편화)

### 4.1 MTU와 단편화가 생기는 이유

- 링크마다 한 번에 실을 수 있는 최대 프레임 크기: **MTU (Maximum Transmission Unit)**.
- IP 데이터그램이 MTU보다 크면 링크 계층에 그대로 못 실음.

### 4.2 IPv4 단편화 방식

- 송신 데이터그램을 여러 **Fragment (조각)** 으로 쪼개 전송.
- 수신 측에서 재조립.
- 관련 필드:
  - **Identification**: 원본 데이터그램 식별
  - **Fragment Offset**: 원본에서의 위치
  - **MF (More Fragments) 플래그**: 뒤에 조각이 더 있는지

- 단편화는 오버헤드/손실 확률 증가를 유발(조각 중 하나만 잃어도 전체 재조립 실패).

---

## 5. IPv4 to IPv6 (IPv4에서 IPv6로)

### 5.1 IPv6 동기

- 주소 고갈(IPv4 32-bit 한계)
- 헤더 단순화/확장성 개선

### 5.2 IPv6 Datagram (IPv6 데이터그램) 특징

- **128-bit 주소**
- 기본 헤더가 더 단순(일부 필드 제거/변경):
  - IPv4의 헤더 체크섬 제거(성능/중복 기능 고려)
  - 단편화는 기본적으로 라우터가 하지 않음(송신단에서 처리, 확장 헤더로)

- **Flow Label** 등 QoS/플로우 식별 지원.

### 5.3 Transition Mechanisms (전환 메커니즘)

- **Tunneling (터널링)**
  - IPv6 패킷을 IPv4 페이로드로 캡슐화해 IPv4 네트워크를 통과.

- (실제 전환은 혼합 환경이 길게 지속될 수 있음)

---

## 6. Addressing in Practice: Subnets, DHCP, CIDR (주소/서브넷/할당)

### 6.1 Subnet (서브넷)

- 같은 서브넷 내 호스트는 라우터를 거치지 않고 서로 직접 도달 가능한 범위.
- 서브넷은 보통 **프리픽스/서브넷 마스크** 로 표현.

### 6.2 CIDR (Classless InterDomain Routing)

- 클래스 A/B/C 고정 경계를 쓰지 않고 프리픽스 길이로 표현.
- 표기: `a.b.c.d/x` (x = 프리픽스 길이).
- 장점: 주소 낭비 감소, 라우팅 테이블 집계(aggregation) 용이.

### 6.3 DHCP (Dynamic Host Configuration Protocol)

- 호스트가 네트워크에 접속하면 자동으로:
  - IP 주소, 서브넷 마스크, 기본 게이트웨이, DNS 서버 등을 받음.

- 일반적 절차(DORA):
  - **Discover → Offer → Request → ACK**

---

## 7. NAT (Network Address Translation)

### 7.1 NAT의 목적/배경

- 사설망 내부 호스트가 **Private IP** 를 쓰고,
- 외부 인터넷에는 **하나(또는 소수)의 Public IP** 로 나가게 하는 기술.
- 주소 부족 완화 + 내부 주소/구조 은닉 효과.

### 7.2 NAT 동작(포트 기반 변환)

- 내부 호스트의 (src IP, src port)을
  - NAT 라우터의 (public IP, new port)로 매핑.

- NAT 장비는 **NAT translation table** 을 유지.

### 7.3 NAT의 논쟁점

- 장점: IPv4 주소 절약, 관리 편의.
- 단점:
  - end-to-end 원칙 약화
  - 서버 운영/피어 투 피어에 불리(외부에서 내부로 연결 어려움)
  - 애플리케이션/프로토콜이 NAT 친화적으로 설계되어야 하는 경우 발생.

---

## 8. Generalized Forwarding and SDN (일반화된 포워딩과 SDN)

### 8.1 전통적 포워딩 vs 일반화된 포워딩

- 전통 라우터: 주로 **Destination IP 프리픽스 매칭** 기반.
- **Generalized Forwarding**: 다양한 헤더 필드(예: 5-tuple, VLAN, MPLS 라벨 등) 매칭 후 동작 수행.

### 8.2 Match + Action (매치-액션) 관점

- 규칙: “어떤 필드 패턴과 매치되면 → 어떤 액션을 한다”
- 액션 예:
  - 특정 포트로 포워딩
  - 드롭
  - 헤더 수정
  - 컨트롤러로 전달

### 8.3 SDN (Software-Defined Networking) 연결고리

- 데이터 플레인은 단순 포워딩(스위치/라우터),
- 컨트롤 플레인은 논리적으로 중앙화된 컨트롤러가 정책/경로를 결정(개념).

---

## 9. Summary (요약)

- 4장은 네트워크 계층 중 **Data Plane**: 라우터가 패킷을 **forwarding** 하는 내부 동작을 다룬다.
- 라우터는 **입력 포트–스위칭 패브릭–출력 포트** 로 구성되고, **Longest Prefix Match** 로 포워딩 결정을 한다.
- 큐잉은 입력/출력에서 발생하며, **HOL 블로킹**, **버퍼 오버플로우 손실**, **스케줄링 정책(FIFO/우선순위/RR/WRR)** 이 성능을 좌우한다.
- **IPv4** 는 best-effort 데이터그램 서비스이며, 헤더에는 TTL/프로토콜/단편화 필드 등이 있다.
- **Fragmentation** 은 MTU 차이로 발생하며 오버헤드를 유발한다.
- **IPv6** 는 128-bit 주소와 단순화된 헤더로 확장성을 높이며, 전환은 **터널링** 등으로 이뤄진다.
- 실전 주소 할당은 **서브넷/CIDR/DHCP** 로 운영되며, **NAT** 는 사설망의 공인 IP 공유를 가능하게 하지만 end-to-end를 약화시킨다.
- 최근 관점에서는 **Generalized Forwarding(매치-액션)** 과 **SDN** 이 데이터 플레인/컨트롤 플레인을 분리해 유연성을 높인다.

# Ch 5. The Network Layer: Control Plane (네트워크 계층: 컨트롤 플레인)

> 개요: **Network Layer(네트워크 계층)** 은 패킷을 출발지 호스트에서 목적지 호스트로 전달하기 위한 기능을 제공한다. 이 중 **4장(Data Plane)** 은 라우터 내부에서 _개별 패킷이 입력 포트에서 출력 포트로 전달되는 과정(Forwarding)_ 을 다루었다. 반면, **5장(Control Plane)** 은 **네트워크 전반에서 경로를 결정하고( Routing ) 이를 각 라우터의 포워딩 테이블에 반영하는 과정**에 초점을 둔다.
>
> 핵심 주제: **Routing Algorithms(라우팅 알고리즘)**, **Link-State / Distance-Vector**, **Intra-AS Routing(RIP/OSPF)**, **Inter-AS Routing(BGP)**, **SDN Control Plane**, **ICMP**

---

## 1. Overview of the Control Plane (컨트롤 플레인 개요)

### 1.1 Control Plane의 역할

- 라우터는 패킷을 전달할 때 **Forwarding Table(FIB)** 을 참조하여 출력 포트를 결정한다.
- 이 테이블은 정적으로 고정되는 값이 아니라,
  - 링크 장애 등 토폴로지 변화
  - 정책 변경 및 트래픽 변화
    와 같은 환경 변화에 따라 **라우팅 프로토콜/알고리즘이 지속적으로 산출 및 갱신**한다.

정리하면 다음과 같다.

- **Data Plane**: 도착한 패킷을 즉시 처리하여 다음 홉으로 전달하는 _로컬 동작_
- **Control Plane**: 포워딩 테이블을 생성·유지하여 네트워크 전체 관점의 경로를 결정하는 _전역 동작_

---

## 2. Routing vs Forwarding (라우팅과 포워딩)

- **Forwarding(포워딩)**: 단일 라우터 내부에서 *입력 포트 → 출력 포트*로 패킷을 전달하는 동작
- **Routing(라우팅)**: 네트워크 전체 관점에서 _출발지 → 목적지_ 경로를 선택하고, 그 결과를 각 라우터의 테이블에 반영하는 동작

---

## 3. Routing Algorithms (라우팅 알고리즘)

라우팅 알고리즘의 목적은 다음과 같다.

> 모든 라우터가 목적지까지 도달하기 위한 “적절한” 경로를 선택하도록 하는 것

### 3.1 경로 비용(Cost, Metric)

경로 선택은 일반적으로 비용(metric)을 최소화하는 방식으로 모델링되며, 비용은 운영 목적에 따라 다음과 같이 정의될 수 있다.

- 홉 수(hop count)
- 지연(delay)
- 링크 대역폭의 역수
- 혼잡(congestion)
- 운영 정책(policy)

---

## 4. Link-State (LS) Routing Algorithm (링크 상태 알고리즘)

### 4.1 핵심 아이디어

- 각 라우터가 **네트워크 전체 토폴로지(graph)** 를 알고 있다고 가정한다.
- 모든 링크 비용을 공유하면, 목적지까지의 최단 경로는 **Dijkstra 알고리즘**으로 계산할 수 있다.

### 4.2 LS의 동작 절차

1. 각 라우터는 인접 라우터와의 링크 비용을 측정한다.
2. 해당 정보를 **Link-State Advertisement(LSA)** 형태로 생성한다.
3. LSA를 네트워크 전역에 **flooding** 하여 모든 라우터가 동일한 토폴로지 정보를 갖도록 한다.
4. 각 라우터는 Dijkstra를 수행하여 **최단경로 트리(SPT)** 를 생성한다.
5. 계산 결과를 Forwarding Table에 반영한다.

### 4.3 LS의 장단점

**장점**

- 일반적으로 수렴(convergence)이 빠르며, 루프 발생 가능성이 상대적으로 낮다.
- 전역 토폴로지를 기반으로 하므로 다양한 최적화가 가능하다.

**단점**

- LSA flooding으로 인한 제어 오버헤드가 발생한다.
- 각 라우터가 전체 그래프를 저장·연산해야 하므로 CPU/메모리 부담이 증가할 수 있다.

---

## 5. Distance-Vector (DV) Routing Algorithm (거리 벡터 알고리즘)

### 5.1 핵심 아이디어 (Bellman-Ford 기반)

- 각 라우터는 네트워크 전체 토폴로지를 알지 못하고, **인접 라우터로부터 전달받는 정보만** 사용한다.
- 라우터는 각 목적지까지의 비용을 벡터 형태로 유지하며, 이웃으로부터 받은 벡터를 이용해 값을 반복 갱신한다.

직관적으로는 다음 관계를 사용한다.

> 목적지까지의 비용 = (이웃까지의 비용) + (이웃이 광고한 목적지까지의 비용) 중 최소값

### 5.2 DV의 동작 방식

- 라우터는 주기적으로, 또는 비용 변화가 있을 때 **이웃 라우터에게 distance vector를 전송**한다.
- 수신한 벡터를 기반으로 자신의 테이블을 갱신한다.
- 갱신이 발생하면 다시 이웃에게 전파되며, 점진적으로 수렴한다.

### 5.3 DV의 대표적 문제: Count-to-Infinity

링크 장애 발생 시, 라우터들이 서로를 통해 목적지에 도달할 수 있다고 잘못 판단하면서 비용이 계속 증가하는 현상이 발생할 수 있다.

### 5.4 완화 기법: Poisoned Reverse

- 특정 목적지로 가는 경로가 “해당 이웃을 통해서만 가능”한 경우, 그 이웃에게는 해당 목적지 비용을 **∞** 로 광고한다.
- 단, 모든 루프 문제를 완전히 제거하는 것은 아니며, 일부 케이스에서만 효과가 있다.

---

## 6. LS vs DV 비교

| 구분          | Link-State (LS)      | Distance-Vector (DV)     |
| ------------- | -------------------- | ------------------------ |
| 네트워크 정보 | 전체 토폴로지 공유   | 이웃 정보만 활용         |
| 계산          | Dijkstra (로컬 계산) | Bellman-Ford (분산 반복) |
| 제어 메시지   | LSA flooding         | 이웃 간 벡터 교환        |
| 수렴 특성     | 상대적으로 빠름      | 상대적으로 느릴 수 있음  |
| 주요 이슈     | flooding/연산 비용   | 루프/Count-to-Infinity   |

---

## 7. Hierarchical Routing (계층적 라우팅)

현실의 인터넷은 규모가 매우 크므로, 모든 라우터가 전역 정보를 완전하게 유지하는 것은 비현실적이다. 이를 해결하기 위해 **AS(Autonomous System)** 단위로 계층화한다.

### 7.1 AS(자율 시스템)

- 동일한 관리 주체(조직/ISP/기관)가 운영하는 라우터 집합
- AS 내부 라우팅: **Intra-AS**
- AS 간 라우팅: **Inter-AS**

---

## 8. Intra-AS Routing (AS 내부 라우팅) — RIP, OSPF

### 8.1 RIP (Routing Information Protocol)

- **Distance-Vector 방식**
- metric: **hop count**
- 최대 홉 제한(일반적으로 15)으로 인해 대규모 네트워크 확장에 한계가 있다.
- 주기적으로 라우팅 정보를 교환한다.

특징

- 구현 및 운영이 단순하다.
- 소규모 네트워크 환경에 적합하다.

### 8.2 OSPF (Open Shortest Path First)

- **Link-State 방식**
- metric: 관리자가 설정 가능한 **cost**
- LSA flooding + Dijkstra로 최단 경로를 산출한다.

OSPF의 운영상 특징

- 수렴이 빠르고 확장성이 우수하다.
- **Area(영역)** 개념을 통해 계층적 구성이 가능하다.
- 인증(authentication) 등 운영 기능을 지원한다.

---

## 9. Inter-AS Routing (AS 간 라우팅) — BGP

### 9.1 BGP의 중요성

AS 간 경로 선택은 최단 경로만으로 결정되지 않고, **정책(policy)** 및 **비즈니스 관계**가 중요하게 작용한다.

예시

- 비용 지불 관계에 따른 경로 우선순위
- 특정 경로/사업자를 경유하지 않도록 하는 정책
- 지역·국가 기반의 경로 회피 정책

즉, Inter-AS 라우팅에서는 “최단거리”보다 “정책 기반 선택”이 핵심이다.

### 9.2 BGP의 기본 개념

- **BGP(Border Gateway Protocol)** 는 AS 간에 특정 프리픽스(prefix)에 대한 도달 가능성을 광고하는 프로토콜이다.
- BGP 라우터는 일반적으로 AS 경계에 위치한 **gateway router** 이다.

BGP가 전달하는 정보(핵심)

- 목적지 프리픽스(CIDR)
- **AS-PATH**: 경로가 통과하는 AS들의 목록
- NEXT-HOP 등 다양한 속성(attribute)

### 9.3 eBGP vs iBGP

- **eBGP(external BGP)**: 서로 다른 AS 간 경로 정보를 교환한다.
- **iBGP(internal BGP)**: 동일 AS 내부에서 BGP 경로 정보를 공유한다.
  - 내부 최단 경로 계산 자체는 OSPF 등 IGP가 담당하는 경우가 일반적이다.

### 9.4 BGP Path Selection (경로 선택 개요)

BGP는 여러 속성을 고려하여 최종 경로를 선택한다.

- Local Preference(내부 정책)
- AS-PATH 길이(짧을수록 선호)
- NEXT-HOP까지의 IGP 비용
- MED 등 추가 속성

#### Hot Potato Routing

- 가능한 한 빠르게 트래픽을 외부 AS로 넘기기 위해, 내부 비용이 낮은 egress를 선호하는 전략이다.

### 9.5 Prefix Aggregation

여러 프리픽스를 하나의 더 큰 프리픽스로 집계하여 광고하면 라우팅 테이블 규모를 줄일 수 있다.

---

## 10. SDN Control Plane (SDN 컨트롤 플레인)

### 10.1 전통적 모델: 라우터별 분산 제어

- 각 라우터가 분산적으로 라우팅 프로토콜(OSPF/BGP 등)을 수행한다.
- 제어 로직이 라우터에 내장되어 운영·정책 적용이 복잡해질 수 있다.

### 10.2 SDN 모델: 논리적 중앙화

- **Control Plane**: 논리적으로 중앙화된 컨트롤러가 정책 및 경로를 결정한다.
- **Data Plane**: 스위치/라우터는 **Match + Action** 규칙에 따라 포워딩을 수행한다.

### 10.3 SDN의 장점

- 정책을 중앙에서 일관되게 적용할 수 있다.
- 기능 추가/변경이 상대적으로 용이하다.
- 트래픽 엔지니어링 및 자동화에 유리하다.

---

## 11. ICMP (Internet Control Message Protocol)

### 11.1 ICMP의 목적

IP는 best-effort 서비스 모델이므로 오류·상태 정보를 별도의 제어 메시지로 전달할 필요가 있다. ICMP는 이러한 목적을 위해 사용된다.

### 11.2 대표 메시지 유형

- Destination Unreachable(목적지 도달 불가)
- Time Exceeded(TTL 만료) — traceroute에서 활용
- Echo Request/Reply — ping에서 활용

---

## 12. Summary (요약)

- **Control Plane** 은 라우터들의 **Forwarding Table을 생성·유지**하며, 네트워크 전반의 경로를 결정하는 영역이다.
- 라우팅 알고리즘은 크게 다음 두 계열로 구분된다.
  - **Link-State(LS)**: 전역 토폴로지 공유 + Dijkstra 기반 최단 경로 계산
  - **Distance-Vector(DV)**: 이웃 정보 기반 반복 갱신(Bellman-Ford) 및 점진적 수렴

- 인터넷은 규모 문제로 **AS 기반 계층화**를 사용한다.
  - **Intra-AS(IGP)**: RIP, OSPF
  - **Inter-AS(EGP)**: BGP(정책 중심)

- **BGP** 는 AS 간 프리픽스 도달 가능성을 광고하고, 다양한 속성에 기반해 정책적으로 경로를 선택한다.
- **SDN** 은 컨트롤 플레인을 논리적으로 중앙화하여 데이터 플레인을 규칙 기반으로 제어한다.
- **ICMP** 는 네트워크 오류 및 상태 정보를 전달하며 ping/traceroute에서 활용된다.

---

# Ch 6. The Link Layer and LANs (링크 계층과 LAN)

> 개요: **Link Layer(링크 계층)** 은 _인접한 노드(호스트↔스위치, 스위치↔스위치, 호스트↔라우터 등)_ 사이에서 **프레임(frame)** 단위로 데이터를 전달한다. 이 장은 (1) 링크 계층이 제공하는 서비스와 동작 위치, (2) 오류 검출/정정, (3) 공유 매체에서의 다중 접속(MAC) 문제, (4) 이더넷·스위치드 LAN·VLAN, (5) 주소 해석(ARP), (6) 광역 링크/가상화(MPLS) 관점까지를 체계적으로 다룬다.

---

## 1. Introduction to the Link Layer (링크 계층 개요)

### 1.1 링크 계층의 역할

- 링크 계층은 **한 홉(one hop)** 전송을 담당한다.
  - 네트워크 계층(IP)이 _종단 간(end-to-end)_ 전달을 목표로 한다면,
  - 링크 계층은 **각 링크에서의 인접 노드 간 전달**을 수행한다.

### 1.2 Nodes, Links, and Frames (노드·링크·프레임)

- **Node(노드)**: 호스트, 라우터, 스위치, AP 등 링크 계층 기능을 수행하는 장치
- **Link(링크)**: 유선/무선 매체로 연결된 인접 노드 간 통신 경로
- **Frame(프레임)**: 링크 계층 PDU(Protocol Data Unit)
  - 네트워크 계층 데이터그램(IP 패킷)을 **캡슐화(encapsulation)** 하여 전송

### 1.3 링크 계층이 구현되는 위치

- 링크 계층 기능은 주로 **네트워크 인터페이스 카드(NIC)** 및 **디바이스 드라이버/펌웨어**에 구현되며, 일부 기능은 OS가 보조한다.

---

## 2. Services Provided by the Link Layer (링크 계층 서비스)

링크 계층은 링크 유형에 따라 다양한 서비스를 제공하며, 대표적으로 다음을 포함한다.

### 2.1 Framing (프레이밍)

- IP 데이터그램에 헤더/트레일러를 부착하여 **프레임**으로 구성
- 프레임 경계(frame boundary) 식별 및 매체 접근에 필요한 필드 제공

### 2.2 Link Access (MAC) (링크 접근/MAC)

- 공유 매체 환경에서 여러 노드가 동일 채널을 사용하므로,
  - **누가 언제 전송할지**를 결정하는 규칙이 필요하다.

- 이를 **MAC(Medium Access Control)** 이 담당한다.

### 2.3 Reliable Delivery (신뢰적 전달) — 선택적

- 링크에서의 손실/오류가 큰 환경(예: 무선)에서는
  - 링크 계층이 재전송(ARQ) 등으로 신뢰성을 제공할 수 있다.

- 다만, 유선 이더넷 등에서는 일반적으로 링크 계층 신뢰성 제공이 제한적이며, 종단 간 신뢰성은 전송 계층(TCP)이 담당한다.

### 2.4 Error Detection/Correction (오류 검출/정정)

- 비트 오류를 검출하기 위해 CRC 등을 사용
- 일부 링크는 FEC(Forward Error Correction)로 오류 정정을 수행하기도 한다.

### 2.5 Flow Control (흐름 제어) — 링크 단위

- 송신 측이 수신 측 처리 능력을 초과하지 않도록 제어(프로토콜에 따라 제공 여부 상이)

---

## 3. Error Detection and Correction (오류 검출과 정정)

### 3.1 오류의 원인과 목표

- 물리 매체 잡음, 간섭, 감쇠, 충돌 등으로 비트 오류가 발생할 수 있다.
- 링크 계층은 오류를
  - **검출(detection)** 하여 상위로 알리거나 재전송을 유도하고,
  - 경우에 따라 **정정(correction)** 하여 복구한다.

### 3.2 Error Detection: CRC (순환 중복 검사)

- 프레임 비트열을 다항식으로 해석하여, 생성 다항식(generator) 기반으로 **체크 비트**를 계산
- 수신 측은 동일 방식으로 검증하여 오류를 높은 확률로 검출한다.

특징

- 구현 효율이 높고 검출 성능이 우수하여 광범위하게 사용된다.
- “완전 무오류”가 아니라 **확률적 검출**임을 전제로 한다.

### 3.3 Error Correction: FEC (전방 오류 정정)

- 수신 측이 추가 정보로 오류를 스스로 복구하는 방식
- 재전송 비용이 큰 환경(위성, 일부 무선)에서 유리

---

## 4. Multiple Access Links and Protocols (다중 접속 링크와 프로토콜)

공유 매체(shared medium)에서는 여러 노드가 같은 채널을 사용하므로 충돌/경쟁을 해결해야 한다.

### 4.1 MAC Protocol의 분류

MAC 프로토콜은 일반적으로 세 가지 계열로 분류한다.

1. **Channel Partitioning (채널 분할)**

- TDMA/FDMA/CDMA 등
- 장점: 충돌이 없고 예측 가능
- 단점: 트래픽이 버스트하거나 사용률이 낮을 때 자원 낭비

2. **Random Access (랜덤 접근)**

- 노드가 전송을 시도하되, 충돌 발생 시 랜덤 백오프(backoff)로 재시도
- 예: (고전적) ALOHA, Slotted ALOHA, CSMA, CSMA/CD

3. **Taking Turns (순번 기반)**

- 노드가 번갈아 전송하도록 제어
- 예: polling, token passing

### 4.2 Random Access: CSMA/CD (이더넷의 고전적 방식)

- **CSMA(Carrier Sense)**: 전송 전 채널이 비어 있는지 감지
- **CD(Collision Detection)**: 전송 중 충돌을 감지하면 즉시 중단하고 백오프 후 재시도

주의

- 현대의 스위치드 이더넷(전이중, full-duplex)에서는 충돌 도메인이 분리되어 CSMA/CD가 실질적으로 사용되지 않는 경우가 많다.

### 4.3 Random Access: CSMA/CA (무선에서의 충돌 회피)

- 무선은 충돌 감지가 어렵고(hidden terminal 등) 특수 문제가 존재하므로
  - **충돌 감지(CD)** 대신 **충돌 회피(CA)** 중심으로 설계된다.

---

## 5. Switched Local Area Networks (스위치드 LAN)

### 5.1 Link-Layer Addressing: MAC Address (MAC 주소)

- 링크 계층 주소는 일반적으로 **MAC address(48-bit)** 를 사용한다.
- IP 주소는 계층적(프리픽스 기반)인 반면,
  - MAC 주소는 평면(flat) 주소이며, 같은 LAN 내 전달에 사용된다.

### 5.2 Ethernet (이더넷)

- 유선 LAN의 사실상 표준
- 핵심 특성
  - 단순한 프레임 구조
  - 베스트 에포트(best-effort) 전달
  - 스위치 기반 확장

#### 5.2.1 Ethernet Frame Format (이더넷 프레임 포맷)

- **Preamble**: 동기화
- **Destination MAC / Source MAC**
- **Type**: 상위 프로토콜(예: IPv4, ARP 등)
- **Payload(Data)**
- **CRC**: 오류 검출

### 5.3 Link-Layer Switches (링크 계층 스위치)

스위치는 링크 계층에서 프레임을 전달하며, 다음과 같은 특징을 가진다.

- **Store-and-Forward**: 프레임을 수신 후(대개 CRC 포함) 전달
- **Switching Table(MAC Table)**: MAC 주소 → 출력 포트 매핑
- **Self-Learning(자기 학습)**
  - 프레임의 **Source MAC** 을 보고 “이 주소는 이 포트에서 들어온다”를 기록
  - 일정 시간 사용되지 않으면 엔트리를 만료(aging)

#### 5.3.1 Filtering and Forwarding (필터링과 포워딩)

- 목적지 MAC이 테이블에 있으면 해당 포트로만 전달
- 없으면 **flooding**(모든 포트로 확산)하여 목적지 학습을 유도

### 5.4 Switches vs Routers (스위치와 라우터 비교)

- **스위치**: 링크 계층 기반(MAC) 전달, LAN 내부 확장에 강점
- **라우터**: 네트워크 계층(IP) 기반 전달, 서브넷 간 연결 및 정책/경로 제어에 강점

---

## 6. Virtual LANs (VLAN)

### 6.1 VLAN의 필요성

- 단일 물리 LAN을 그대로 확장하면
  - 브로드캐스트 트래픽 증가
  - 보안/격리 요구 대응 어려움
  - 관리 복잡성 증가

### 6.2 VLAN의 개념

- 하나의 물리 스위치 인프라를 **논리적으로 분할**하여
  - 서로 다른 브로드캐스트 도메인을 구성한다.

### 6.3 VLAN Tagging (802.1Q)

- 프레임에 VLAN 태그를 삽입하여 VLAN ID를 표현
- 스위치 간 트렁크(trunk) 링크에서 여러 VLAN 트래픽을 함께 운반 가능

---

## 7. Address Resolution Protocol (ARP)

### 7.1 ARP의 목적

- 같은 서브넷 내에서 IP 데이터그램을 전송하려면
  - 목적지(또는 기본 게이트웨이)의 **MAC 주소**가 필요하다.

- ARP는 **IP 주소 → MAC 주소**를 해석하는 프로토콜이다.

### 7.2 ARP 동작 방식(개요)

1. 송신 호스트는 ARP 캐시를 조회한다.
2. 없으면 **ARP Request** 를 브로드캐스트한다.
3. 해당 IP를 가진 노드는 **ARP Reply** 로 자신의 MAC을 유니캐스트 응답한다.
4. 송신 호스트는 매핑을 캐시에 저장한다(시간 기반 만료).

---

## 8. Beyond Ethernet: Point-to-Point Links and MPLS (이더넷을 넘어)

### 8.1 Point-to-Point Protocol (PPP) — 개요

- 포인트-투-포인트 링크에서 사용되는 링크 계층 프로토콜의 한 예
- 프레이밍, 링크 구성, 인증 등의 기능을 제공할 수 있다.

### 8.2 MPLS (Multi-Protocol Label Switching)

- IP 라우팅(목적지 프리픽스 기반)과 달리, MPLS는
  - 패킷에 **라벨(label)** 을 부착하고
  - 라우터(정확히는 LSR)가 라벨을 기반으로 빠르게 포워딩한다.

특징

- 트래픽 엔지니어링(TE) 및 정책 기반 경로 제어에 활용 가능
- “네트워크 계층과 링크 계층 사이(2.5 계층)”로 설명되기도 하나, 본질은 **라벨 스위칭 기반 포워딩**이다.

---

## 9. Data Center Networking (데이터센터 네트워킹) — 개요

대규모 데이터센터에서는 다음 요구가 두드러진다.

- 매우 높은 동서 트래픽(east-west) 비중
- 다수의 서버/VM/컨테이너를 수용하는 확장성
- 장애 격리 및 빠른 복구

이에 따라 스위치 계층 구조, 링크 중복, 로드밸런싱, 가상 네트워크(오버레이) 등이 중요한 설계 요소가 된다.

---

## 10. Summary (요약)

- **링크 계층**은 인접 노드 간 **한 홉 전송**을 담당하며, 단위는 **프레임**이다.
- 주요 기능은 **프레이밍**, **MAC(다중 접속 제어)**, **오류 검출/정정(CRC/FEC)**, (선택적으로) **신뢰적 전달/흐름 제어**이다.
- 공유 매체에서는 MAC 프로토콜이 필요하며, 채널 분할/랜덤 접근/순번 기반으로 분류된다.
- **이더넷**은 대표적인 LAN 기술이며, **스위치**는 자기 학습과 MAC 테이블을 통해 프레임을 효율적으로 전달한다.
- **VLAN(802.1Q)** 은 물리 인프라를 논리적으로 분할하여 브로드캐스트 도메인 격리 및 관리성을 향상한다.
- **ARP** 는 동일 서브넷에서 IP→MAC 주소 해석을 제공한다.
- **MPLS** 는 라벨 기반 포워딩으로 트래픽 엔지니어링 및 정책 적용에 활용되며, 데이터센터 환경에서는 확장성과 가용성을 중심으로 네트워크가 설계된다.
