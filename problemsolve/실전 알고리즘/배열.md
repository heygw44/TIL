> 바킹독님의 실전 알고리즘 강좌를 듣고 정리한 내용입니다.

# 배열

## 배열의 정의와 성질
- 정의: 메모리 상에 원소를 연속하게 배치한 자료구조.
- 핵심 성질
  - $O(1)$접근: k번째 원소의 위치를 바로 계산가능하기 때문에 확인/변경이 $O(1)$이다.
  - 메모리 오버헤드: 추가적인 메모리 공간 소모가 거의 없다.   
  - 캐시 히트 레이트: 메모리 상에 데이터가 연속적이기 때문에 캐시 적중률이 높다.
  - 메모리 할당: 고정된 크기의 메모리를 할당한다.

## 시간 복잡도
- 임의의 위치 접근/변경: $O(1)$
- 끝에 원소 추가/삭제: $O(1)$
- 임의의 위치에 원소 추가/삭제: $O(N)$
  - 중간에 원소를 넣거나 빼려면, 그 뒤에 있는 모든 원소를 한 칸씩 밀거나 당겨야(Shift) 하므로 데이터 개수 $N$에 비례하는 시간이 걸린다.

## 배열 초기화 팁
코딩 테스트에서 배열을 0이나 특정 값으로 초기화할 때의 주의점.

1. `memset`
- 헤더: `<cstring>`
- 빠르지만 실수할여지가 많다.
- 0이나 -1이 아닌 다른 값으로 초기화하면 의도치 않은 값이 들어간다.
- 0이나 -1로 초기화할때만 사용하도록 하자.
2. `std::fill`
- 헤더: `<algorithm>`
- 실수할 여지가 없고 코드가 직관적이다.
```cpp
int a[21];
int b[21][21];

// 1차원 배열: fill(시작 주소, 끝 주소, 값)
fill(a, a+21, 0); 

// 2차원 배열: 
for(int i=0; i<21; i++) fill(b[i], b[i]+21, 0);
```

## STL Vector
- 배열과 거의 동일한 기능을 제공하지만, 크기를 자유자재로 늘리거나 줄일 수 있는 동적배열.
- 코딩 테스트에서는 크기를 미리 알기 어려운 경우나 그래프의 인접 리스트 등을 저장할 때 필수적으로 사용한다.
- `insert`, `erase`메서드가 존재하지만 배열과 마찬가지로 시간 복잡도는 $O(N)$이다.
- `push_back`, `pop_back`은 $O(1)$

## 배열 관련 테크닉 (공간으로 시간을 사자)
- 문제 상황: 배열에 있는 수 중 합이 100이 되는 쌍이 있는지 확인하라.
- 나이브한 풀이: 이중 for문 → $O(N^2)$
- 효율적인 풀이: 배열을 만들어 각 숫자의 등장 여부를 저장하자.         →$O(N)$
```cpp
int arr[N];
int occur[101]; // 각 숫자가 나왔는지 체크하는 배열

for(int i=0; i<N; i++) {
    if(occur[100 - arr[i]] == 1) {
        // 짝을 찾음!
    }
    occur[arr[i]] = 1;
}
```
- 데이터의 범위가 작으면, 배열의 인덱스를 값 자체로 활용하여 탐색 시간을 `O(1)`으로 줄이는게 가능!