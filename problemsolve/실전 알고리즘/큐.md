> 바킹독님의 실전 알고리즘 강좌를 듣고 정리한 내용입니다.

# 큐

## 큐의 정의와 성질
- 정의: 한쪽 끝(Rear)에서는 원소를 넣고, 반대쪽 끝(Front)에서는 원소를 뺼 수 있는 자료구조.
- FIFO 구조
- 시간 복잡도
  - 원소 추가(`push`): $O(1)$
  - 원소 제거(`pop`): $O(1)$
  - 제일 앞/뒤 원소 확인(`front/back`): $O(1)$
  - 중간에 있는 원소 확인/변경: 원칙적으로 불가능.

## 자료구조 구현

### STL `std::queue`
- 헤더 `<queue>`
- 코테에서는 특별한 이유가 없다면 STL을 사용하자.
- 주요 함수:
  - `push(val)`: 뒤쪽에 값 추가
  - `pop()`: 앞쪽 값 제거 (반환값 없음)
  - `front()`: 맨 앞의 값 반환
  - `back()`: 맨 뒤의 값 반환
  - `empty()`: 비어있으면 true
  - `size()`: 원소 개수
- 주의사항: 큐가 비어있을 때 `pop(), front(), back()`을 호출하면 런타임 에러가 발생한다. 반드시 `!Q.empty()`를 확인해야 한다.

### 배열을 이용한 구현
```cpp
const int MX = 1000005;
int dat[MX];
int head = 0, tail = 0;

void push(int x) { dat[tail++] = x; }
void pop() { head++; }
int front() { return dat[head]; }
int back() { return dat[tail-1]; }
```
- `head`: 가장 앞 원소의 인덱스
- `tail`: 가장 뒤에 있는 원소의 바로 다음 인덱스(다음에 원소가 들어갈 자리)
- 크기(Size): `tail` - `head`

### 원형 큐의 개념
- 문제점: 배열로 만든 선형큐에서 `pop`를 계속하면 `head`가 밀리면서 앞쪽 공간이 낭비.
- 해결법: `head`와 `tail`이 배열의 끝에 도달하면 다시 0번지로 돌아가게 만든다.(모듈러 연산 활용)
- 코테 팁: 원형큐를 직접 구현하는것은 매우 번거로운 작업.
  - 그냥 STL큐를 사용하거나,
  - 배열 크기를 충분히 크게(입력의 크기만큼)잡아서 선형 큐로 구현하자.

### 큐의 활용
- BFS(너비 우선 탐색)
  - 큐가 가장 중요하게 쓰이는곳.
  - 시작점에서 거리가 1인곳들, 그다음 거리가 2인곳들... 순서로 방문할때 큐의 FIFO 성질 이용.
  - Flood FIll: 그림판의 페인트 통 기능처럼 연결된 영역을 채우는 알고리즘에도 사용한다.